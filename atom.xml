<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李特个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.litede.cn/"/>
  <updated>2019-11-02T02:41:56.526Z</updated>
  <id>http://www.litede.cn/</id>
  
  <author>
    <name>李特</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用集合类(七) -- HashSet</title>
    <link href="http://www.litede.cn/2019/11/02/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%B8%83-HashSet/"/>
    <id>http://www.litede.cn/2019/11/02/常用集合类-七-HashSet/</id>
    <published>2019-11-02T02:08:13.000Z</published>
    <updated>2019-11-02T02:41:56.526Z</updated>
    
    <content type="html"><![CDATA[<p>HashSet是Set集合的哈希实现,其继承了AbstractSet抽象类,并实现了Set接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">    extends AbstractSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// HashSet内部使用HashMap存储</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">// 存储在value上的值</span><br><span class="line">private static final Object PRESENT = new Object();</span><br></pre></td></tr></table></figure><p>从类成员变量我们可以知道，HashSet 内部使用 HashMap 存储，而 PRESENT 则是存储在所有 key 上的 value。因此对于 HashSet 来说，其所有 key 的 value 都相同。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashSet一共有5个构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashSet(int initialCapacity) &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到构造方法传入的参数其实就是用于初始化 HashMap 对象，主要有：initialCapacity（初始大小）、loadFactor（扩容因子）。这几个构造参数内容并不复杂，这里就不细讲了。</p></li><li><p>这里有一个关键的细节，即第 5 个方法使用 LinkedHashMap 实现的，而不是用 HashMap 实现的。而我们后面要讲到的 LinkedHashSet 其实就是使用 LinkedHashMap 实现的，其保存了插入元素的顺序。</p></li><li><p>第二个构造方法调用了addAll(c),其源码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    boolean modified = false;</span><br><span class="line">    for (E e : c)</span><br><span class="line">        if (add(e))</span><br><span class="line">            modified = true;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到Collection 中默认不支持添加单个元素，如果直接调用 add(E) 方法，会报错,因此，如果子类是可添加的数据结构，需要自己实现 add(E) 方法。所以,调用 add() 方法添加，如果没有实现 add(E) 方法，addAll() 也不能用</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>对于 HashSet 来说，其核心的方法有：add、remove。</p><ol><li>add 方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return map.put(e, PRESENT)==null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>可以看到 add 方法直接调用了 HashMap 对象的 put 方法。如果 Set 集合插入成功，那么就返回 true，否则返回 false。</li><li>就把元素e存放在了map里面。但是值得注意的是元素值作为的是map的key，map的value则是前面提到的PRESENT变量，这个变量只作为放入map时的一个占位符而存在，所以没什么实际用处。其实，这时候答案已经出来了：<strong>HashMap的key是不能重复的，而这里HashSet的元素又是作为了map的key，当然也不能重复了</strong></li></ul><ol start="2"><li>remove 方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到 remove 方法直接调用了 HashMap 对象的 remove 方法。如果删除成功，就返回 true，否则返回 false。</p><h1 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h1><ol><li>通过Iterator遍历HashSet</li></ol><p>第一步 通过Iterator()获取HashSet的迭代器</p><p>第二部 遍历迭代器获取各个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 假设set是HashSet对象</span><br><span class="line">for(Iterator iterator = set.iterator();</span><br><span class="line">       iterator.hasNext(); ) &#123; </span><br><span class="line">    iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过for-each遍历HashSet</li></ol><p>第一步：根据toArray()获取HashSet的元素集合对应的数组。</p><p>第二步：遍历数组，获取各个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 假设set是HashSet对象，并且set中元素是String类型</span><br><span class="line">String[] arr = (String[])set.toArray(new String[0]);</span><br><span class="line">for (String str:arr)</span><br><span class="line">    System.out.printf(&quot;for each : %s\n&quot;, str);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>HashSet 是一个没有重复元素的集合。</li><li>它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。</li><li>HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashSet是Set集合的哈希实现,其继承了AbstractSet抽象类,并实现了Set接口&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(六) -- Stack栈的原理</title>
    <link href="http://www.litede.cn/2019/11/01/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E5%85%AD-Stack%E6%A0%88%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://www.litede.cn/2019/11/01/常用集合类-六-Stack栈的原理/</id>
    <published>2019-11-01T08:46:42.000Z</published>
    <updated>2019-11-02T00:43:21.865Z</updated>
    
    <content type="html"><![CDATA[<p>Stack是先进后出的栈结构,其并不直接实现具体的逻辑,而是通过集成Vector类,调用Vector类的方法实现.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public </span><br><span class="line">class Stack&lt;E&gt; extends Vector&lt;E&gt;</span><br></pre></td></tr></table></figure><h1 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h1><p>Stack类代码非常简单,其有3个核心方法:<strong>push pop peek</strong></p><h2 id="push-插入"><a href="#push-插入" class="headerlink" title="push 插入"></a>push 插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E push(E item) &#123;</span><br><span class="line">    addElement(item);</span><br><span class="line"></span><br><span class="line">    return item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用父方法Vector的<a href="http://www.litede.cn/2019/10/28/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%94-Vector/">addElement()</a>方法实现将元素插入到数组尾部</p><h2 id="pop-删除"><a href="#pop-删除" class="headerlink" title="pop 删除"></a>pop 删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E pop() &#123;</span><br><span class="line">    E       obj;</span><br><span class="line">    int     len = size();</span><br><span class="line"></span><br><span class="line">    obj = peek();</span><br><span class="line">    removeElementAt(len - 1);</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用父方法Vector的<a href="http://www.litede.cn/2019/10/28/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%94-Vector/">removeElementAt()</a>方法实现将删除数组的<strong>最后一个</strong>元素,注: 不是删除第一个元素</p><h2 id="peek-返回列表的最后一个元素"><a href="#peek-返回列表的最后一个元素" class="headerlink" title="peek 返回列表的最后一个元素"></a>peek 返回列表的最后一个元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E peek() &#123;</span><br><span class="line">    int     len = size();</span><br><span class="line"></span><br><span class="line">    if (len == 0)</span><br><span class="line">        throw new EmptyStackException();</span><br><span class="line">    return elementAt(len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用父方法Vector的<a href="http://www.litede.cn/2019/10/28/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%94-Vector/">elementAt()</a>方法直接返回列表最后一个元素</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>栈最大的特点是先进后出，所以逆序输出是栈经常用到的一个应用场景。首先把所有元素依次入栈，然后把所有元素出栈并输出，这样就实现了逆序输出。</p><h2 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h2><p>将十进制的数转换为2-9的任意进制的数</p><p>我们都知道，通过求余法，可以将十进制数转换为其他进制，比如要转为八进制，将十进制数除以8，记录余数，然后继续将商除以8，一直到商等于0为止，最后将余数倒着写数来就可以了。</p><p>比如100的八进制，100首先除以8商12余4,4首先进栈，然后12除以8商1余4，第二个余数4进栈，接着1除以8，商0余1，第三个余数1进栈，最后将三个余数出栈，就得到了100的八进制数144,。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*其实这里略有问题的</span><br><span class="line">   * 例如16进制的表示</span><br><span class="line">   * 14进制的表示</span><br><span class="line">   * 若14进制数为124：无法确定其具体是什么*/</span><br><span class="line">  public static String conversion(int num, int n) &#123;  </span><br><span class="line">      Stack&lt;Integer&gt; myStack = new ArrayStack&lt;Integer&gt;();  </span><br><span class="line">      Integer result = num;  </span><br><span class="line">      while (true) &#123;  </span><br><span class="line">          // 将余数入栈  </span><br><span class="line">          myStack.push(result % n);  </span><br><span class="line">          result = result / n;  </span><br><span class="line">          if (result == 0) &#123;  </span><br><span class="line">              break;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      StringBuilder sb = new StringBuilder();  </span><br><span class="line">      // 按出栈的顺序倒序排列即可  </span><br><span class="line">      while ((result = myStack.pop()) != null) &#123;  </span><br><span class="line">          sb.append(result);  </span><br><span class="line">      &#125;  </span><br><span class="line">      return sb.toString();  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="平衡符号的判断"><a href="#平衡符号的判断" class="headerlink" title="平衡符号的判断"></a>平衡符号的判断</h2><p>匹配思想是： </p><ol><li><p>首先读入字符串保存在字符数组中</p></li><li><p>依次判断每个字符，如果是开放字符则压入栈中</p></li><li><p>如果是关闭字符而且此时栈为空的话，那么字符串非平衡串，否则栈顶元素弹出并与该字符进行比较若能够成对匹配则继续，否则非平衡串。</p></li><li><p>在字符数组结尾处，如果栈非空则非平衡串，反之则是。    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*提取去需要检查的序列*/</span><br><span class="line">    public static String strFilter(String string)</span><br><span class="line">    &#123;</span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        char[] chars = string.toCharArray();</span><br><span class="line">       </span><br><span class="line">        for(char c:chars)</span><br><span class="line">          if(c==&apos;[&apos;||c==&apos;&#123;&apos;||c==&apos;(&apos;||c==&apos;]&apos;||c==&apos;&#125;&apos;||c==&apos;)&apos;)</span><br><span class="line">              sb.append(c);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static boolean isMatch(String str) &#123;  </span><br><span class="line">        Stack&lt;Character&gt; myStack = new ArrayStack&lt;Character&gt;();  </span><br><span class="line">        char[] arr = strFilter(str).toCharArray(); </span><br><span class="line">        System.out.println(strFilter(str));</span><br><span class="line">        for (char c : arr) &#123;  </span><br><span class="line">            Character temp = myStack.pop();  </span><br><span class="line">            // 栈为空时只将c入栈  </span><br><span class="line">            if (temp == null) &#123;  </span><br><span class="line">                myStack.push(c);  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 配对时c不入栈  </span><br><span class="line">            else if (temp == &apos;[&apos; &amp;&amp; c == &apos;]&apos;) &#123;  </span><br><span class="line">            &#125;   </span><br><span class="line">            // 配对时c不入栈  </span><br><span class="line">            else if (temp == &apos;(&apos; &amp;&amp; c == &apos;)&apos;) &#123;  </span><br><span class="line">            &#125;   </span><br><span class="line">            else if (temp == &apos;&#123;&apos; &amp;&amp; c == &apos;&#125;&apos;) &#123;  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 不配对时c入栈  </span><br><span class="line">            else &#123;  </span><br><span class="line">                myStack.push(temp);  </span><br><span class="line">                myStack.push(c);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return myStack.isEmpty();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   String str = &quot;sdfsdf&#123;5*&#123;2+5*(4+6)&#125;&#125;sdf&quot;;</span><br><span class="line">System.out.println(isMatch(str));</span><br></pre></td></tr></table></figure><p> 运行结果：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;()&#125;&#125;</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h2 id="行编辑器"><a href="#行编辑器" class="headerlink" title="行编辑器"></a>行编辑器</h2><p> 输入行中字符‘#’表示退格‘@’表示前面的输入无效</p><p> 来看实现方式吧        </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static String lineEdit(String input) &#123;</span><br><span class="line">Stack&lt;Character&gt; myStack = new ArrayStack&lt;Character&gt;();</span><br><span class="line">char[] arr = input.toCharArray();</span><br><span class="line">for (char c : arr) &#123;</span><br><span class="line">if (c == &apos;#&apos;) &#123;</span><br><span class="line">myStack.pop();</span><br><span class="line">&#125; else if (c == &apos;@&apos;) &#123;</span><br><span class="line">myStack.clear();</span><br><span class="line">&#125; else &#123;                                                                                                                                                    </span><br><span class="line">myStack.push(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return myStack.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(conversion(10, 2));</span><br><span class="line">System.out.println(lineEdit(&quot;你好!#你好啊@哈哈&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1010</span><br><span class="line">ArrayStack</span><br><span class="line">[</span><br><span class="line">    哈</span><br><span class="line">    哈</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>Tips：<strong>后缀表示具有一个优点：没有必要知道各个运算符号的优先级情况</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">private static String infixToSuffix(String infix) &#123;</span><br><span class="line">       Stack&lt; Character&gt; stack = new Stack&lt; Character&gt;();</span><br><span class="line">       String suffix = &quot;&quot;;</span><br><span class="line">       int length = infix.length();</span><br><span class="line">       for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">           Character temp;</span><br><span class="line">           char c = infix.charAt(i);</span><br><span class="line">           switch (c) &#123;</span><br><span class="line">           // 忽略空格</span><br><span class="line">           case &apos; &apos;:</span><br><span class="line">               break;</span><br><span class="line">           // 碰到&apos;(&apos;，push到栈</span><br><span class="line">           case &apos;(&apos;:</span><br><span class="line">               stack.push(c);</span><br><span class="line">               break;</span><br><span class="line">           // 碰到&apos;+&apos;&apos;-&apos;，将栈中所有运算符弹出，送到输出队列中</span><br><span class="line">           case &apos;+&apos;:</span><br><span class="line">           case &apos;-&apos;:</span><br><span class="line">               while (stack.size() != 0) &#123;</span><br><span class="line">                   temp = stack.pop();</span><br><span class="line">                   if (temp == &apos;(&apos;) &#123;</span><br><span class="line">                       stack.push(&apos;(&apos;);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   suffix += &quot; &quot; + temp;</span><br><span class="line">               &#125;</span><br><span class="line">               stack.push(c);</span><br><span class="line">               suffix += &quot; &quot;;</span><br><span class="line">               break;</span><br><span class="line">           // 碰到&apos;*&apos;&apos;/&apos;，将栈中所有乘除运算符弹出，送到输出队列中</span><br><span class="line">           case &apos;*&apos;:</span><br><span class="line">           case &apos;/&apos;:</span><br><span class="line">               while (stack.size() != 0) &#123;</span><br><span class="line">                   temp = stack.pop();</span><br><span class="line">                   if (temp == &apos;(&apos; || temp == &apos;+&apos; || temp == &apos;-&apos;) &#123;</span><br><span class="line">                       stack.push(temp);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       suffix += &quot; &quot; + temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               stack.push(c);</span><br><span class="line">               suffix += &quot; &quot;;</span><br><span class="line">               break;</span><br><span class="line">           // 碰到右括号，将靠近栈顶的第一个左括号上面的运算符全部依次弹出，送至输出队列后，再丢弃左括号</span><br><span class="line">           case &apos;)&apos;:</span><br><span class="line">               while (stack.size() != 0) &#123;</span><br><span class="line">                   temp = stack.pop();</span><br><span class="line">                   if (temp == &apos;(&apos;)</span><br><span class="line">                       break;</span><br><span class="line">                   else</span><br><span class="line">                       suffix += &quot; &quot; + temp;</span><br><span class="line">               &#125;</span><br><span class="line">               //suffix += &quot; &quot;;</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               suffix += c;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       while (stack.size() != 0)</span><br><span class="line">           suffix += &quot; &quot; + stack.pop();</span><br><span class="line">       return suffix;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">        System.out.println(infixToSuffix(&quot;3+(2-5)*6/3&quot;));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果为: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2 5 - 6 * 3 / +</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Stack 方法代码真的是非常简单，其利用 Vector 实现了一个线程安全的栈结构。总的来说，其有以下特点:</p><ul><li>底层采用 Vector 实现，因此其也是采用数组实现，也是线程安全的。</li><li>先进后出的栈结构</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Stack是先进后出的栈结构,其并不直接实现具体的逻辑,而是通过集成Vector类,调用Vector类的方法实现.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(五) -- Vector</title>
    <link href="http://www.litede.cn/2019/10/28/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%94-Vector/"/>
    <id>http://www.litede.cn/2019/10/28/常用集合类-五-Vector/</id>
    <published>2019-10-28T09:09:12.000Z</published>
    <updated>2019-10-29T02:29:53.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><ol><li>Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。</li><li>Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。</li><li>Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供4快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</li><li>Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</li><li>和ArrayList不同，Vector中的操作是<strong>线程安全</strong>的.其实实现很简单就是在每一个可能发生线程安全的方法加上 <strong>synchronized</strong> 关键字。这样就使得任何时候只有一个线程能够进行读写，这样就保证了线程安全。</li><li><strong>Vector 默认扩容为原来的 2 倍</strong>，而 ArrayList 默认扩容为原来的 1.5 倍</li></ol><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 保存Vector中数据的数组</span><br><span class="line">protected Object[] elementData;</span><br><span class="line">// 实际数据的数量</span><br><span class="line">protected int elementCount;</span><br><span class="line">/**</span><br><span class="line">* 容量增长系数  </span><br><span class="line">* 向量容量自动达到的量</span><br><span class="line">* 当其大小大于其容量时增加。 如果</span><br><span class="line">* 容量增量小于或等于零，</span><br><span class="line">* 容量每次增长时，向量的倍数都会增加一倍。</span><br><span class="line">**/</span><br><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>Vector一共有4个构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Vector() &#123;</span><br><span class="line">        this(10);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用this方法跳转到下一个构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">        this(initialCapacity, 0);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用this方法跳转到下一个构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    this.elementData = new Object[initialCapacity];</span><br><span class="line">    this.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public Vector(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line"> elementData = c.toArray();</span><br><span class="line"> elementCount = elementData.length;</span><br><span class="line"> // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line"> if (elementData.getClass() != Object[].class)</span><br><span class="line">     elementData = Arrays.copyOf(elementData, elementCount, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="扩容前兆-检查数量"><a href="#扩容前兆-检查数量" class="headerlink" title="扩容前兆 检查数量"></a>扩容前兆 检查数量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityHelper(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容代码"><a href="#扩容代码" class="headerlink" title="扩容代码"></a>扩容代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line"></span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">     // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。</span><br><span class="line">    // 若容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement</span><br><span class="line">    // 否则，将容量增大一倍。</span><br><span class="line">    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copyInto-将数组Vector的全部元素都拷贝到数组anArray中"><a href="#copyInto-将数组Vector的全部元素都拷贝到数组anArray中" class="headerlink" title="copyInto : // 将数组Vector的全部元素都拷贝到数组anArray中"></a>copyInto : // 将数组Vector的全部元素都拷贝到数组anArray中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void copyInto(Object[] anArray) &#123;</span><br><span class="line">System.arraycopy(elementData, 0, anArray, 0, elementCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ensureCapacity-确定Vector的容量"><a href="#ensureCapacity-确定Vector的容量" class="headerlink" title="ensureCapacity : 确定Vector的容量"></a>ensureCapacity : 确定Vector的容量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">modCount++;</span><br><span class="line">ensureCapacityHelper(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?</span><br><span class="line">                                        capacityIncrement : oldCapacity);</span><br></pre></td></tr></table></figure><p>实现了<strong>容量扩容每次增加一倍的功能</strong></p><h3 id="添加元素的五种方法"><a href="#添加元素的五种方法" class="headerlink" title="添加元素的五种方法"></a>添加元素的五种方法</h3><h4 id="insertElementAt-在指定位置插入一个元素，同步的"><a href="#insertElementAt-在指定位置插入一个元素，同步的" class="headerlink" title="insertElementAt : 在指定位置插入一个元素，同步的"></a>insertElementAt : 在指定位置插入一个元素，同步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void insertElementAt(E obj, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (index &gt; elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + &quot; &gt; &quot; + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addElement-尾部插入元素，同步的"><a href="#addElement-尾部插入元素，同步的" class="headerlink" title="addElement : 尾部插入元素，同步的"></a>addElement : 尾部插入元素，同步的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void addElement(E obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + 1);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll-添加一个集合到尾部，同步的"><a href="#addAll-添加一个集合到尾部，同步的" class="headerlink" title="addAll : 添加一个集合到尾部，同步的"></a>addAll : 添加一个集合到尾部，同步的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    //扩容，复制到数组后面</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line">    System.arraycopy(a, 0, elementData, elementCount, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addAll-添加一个结合到指定位置"><a href="#addAll-添加一个结合到指定位置" class="headerlink" title="addAll : 添加一个结合到指定位置"></a>addAll : 添加一个结合到指定位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (index &lt; 0 || index &gt; elementCount)</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    int numNew = a.length;</span><br><span class="line">    ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">    //要移动多少个元素</span><br><span class="line">    int numMoved = elementCount - index;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        //把插入位置后面的元素后移这么多位</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    //复制元素到数组中</span><br><span class="line">    System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">    elementCount += numNew;</span><br><span class="line">    return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-ListIterator-的添加方法"><a href="#add-ListIterator-的添加方法" class="headerlink" title="add :  ListIterator 的添加方法"></a>add :  ListIterator 的添加方法</h3><p>此方法实在内部类ListItr中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void add(E e) &#123;</span><br><span class="line">    int i = cursor;</span><br><span class="line">    synchronized (Vector.this) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        Vector.this.add(i, e);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = i + 1;</span><br><span class="line">    lastRet = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除的9中方法"><a href="#删除的9中方法" class="headerlink" title="删除的9中方法"></a>删除的9中方法</h3><h4 id="removeElementAt-移除index位置的元素"><a href="#removeElementAt-移除index位置的元素" class="headerlink" title="removeElementAt: 移除index位置的元素"></a>removeElementAt: 移除index位置的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void removeElementAt(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (index &gt;= elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (index &lt; 0) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    int j = elementCount - index - 1;</span><br><span class="line">    if (j &gt; 0) &#123;</span><br><span class="line">        //扩容后就把插入点后面的元素统一后移一位</span><br><span class="line">        System.arraycopy(elementData, index + 1, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount--;</span><br><span class="line">    elementData[elementCount] = null; /* to let gc do its work */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeElement-删除指定元素"><a href="#removeElement-删除指定元素" class="headerlink" title="removeElement : 删除指定元素"></a>removeElement : 删除指定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean removeElement(Object obj) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = indexOf(obj);</span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf(obj)的方法看后面</p><h4 id="remove-删除指定位置的元素"><a href="#remove-删除指定位置的元素" class="headerlink" title="remove : 删除指定位置的元素"></a>remove : 删除指定位置的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E remove(int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (index &gt;= elementCount)</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    //找到删除该元素后，后面有多少位元素需要前移一位</span><br><span class="line">    int numMoved = elementCount - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        //迁移一位</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    //最后一位置为 null，不浪费空间</span><br><span class="line">    elementData[--elementCount] = null; // Let gc do its work</span><br><span class="line"></span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove-删除指定元素"><a href="#remove-删除指定元素" class="headerlink" title="remove : 删除指定元素"></a>remove : 删除指定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    return removeElement(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeAll-删除指定集合的所有元素"><a href="#removeAll-删除指定集合的所有元素" class="headerlink" title="removeAll: 删除指定集合的所有元素"></a>removeAll: 删除指定集合的所有元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    //直接调用 AbstractCollection 的 removeAll 方法，用迭代器挨个删除</span><br><span class="line">    return super.removeAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AbstractCollection 的 removeAll</span><br><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    boolean modified = false;</span><br><span class="line">    Iterator&lt;?&gt; it = iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        if (c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeAllElements-删除所有元素"><a href="#removeAllElements-删除所有元素" class="headerlink" title="removeAllElements : 删除所有元素"></a>removeAllElements : 删除所有元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void removeAllElements() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    // Let gc do its work</span><br><span class="line">    for (int i = 0; i &lt; elementCount; i++)</span><br><span class="line">        elementData[i] = null;</span><br><span class="line"></span><br><span class="line">    elementCount = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeRange-删除指定范围的元素"><a href="#removeRange-删除指定范围的元素" class="headerlink" title="removeRange : 删除指定范围的元素"></a>removeRange : 删除指定范围的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void removeRange(int fromIndex, int toIndex) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    //把结束位置以后的元素向前移动 指定数量个位置，覆盖</span><br><span class="line">    int numMoved = elementCount - toIndex;</span><br><span class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">    // Let gc do its work</span><br><span class="line">    // 把多余的位置置为 null</span><br><span class="line">    int newElementCount = elementCount - (toIndex-fromIndex);</span><br><span class="line">    while (elementCount != newElementCount)</span><br><span class="line">        elementData[--elementCount] = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="retainAll-排除异己"><a href="#retainAll-排除异己" class="headerlink" title="retainAll : 排除异己"></a>retainAll : 排除异己</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    return super.retainAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean retainAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    boolean modified = false;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    while (it.hasNext()) &#123;</span><br><span class="line">        if (!c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeIf-JDK-1-8-新增的"><a href="#removeIf-JDK-1-8-新增的" class="headerlink" title="removeIf :　JDK 1.8 新增的"></a>removeIf :　JDK 1.8 新增的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;</span><br><span class="line">    Objects.requireNonNull(filter);</span><br><span class="line">    // 将要删除的内容加入 removeSet</span><br><span class="line">    int removeCount = 0;</span><br><span class="line">    final int size = elementCount;</span><br><span class="line">    final BitSet removeSet = new BitSet(size);</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        final E element = (E) elementData[i];</span><br><span class="line">        if (filter.test(element)) &#123;</span><br><span class="line">            removeSet.set(i);</span><br><span class="line">            removeCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历，删除</span><br><span class="line">    final boolean anyToRemove = removeCount &gt; 0;</span><br><span class="line">    if (anyToRemove) &#123;</span><br><span class="line">        final int newSize = size - removeCount;</span><br><span class="line">        for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) &#123;</span><br><span class="line">            i = removeSet.nextClearBit(i);</span><br><span class="line">            elementData[j] = elementData[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k=newSize; k &lt; size; k++) &#123;</span><br><span class="line">            elementData[k] = null;  // Let gc do its work</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">        if (modCount != expectedModCount) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return anyToRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h3><h4 id="set-修改指定位置为指定元素"><a href="#set-修改指定位置为指定元素" class="headerlink" title="set : //修改指定位置为指定元素"></a>set : //修改指定位置为指定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E set(int index, E element) &#123;</span><br><span class="line">    if (index &gt;= elementCount)</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    //找到这个元素，直接设置新值</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setElementAt-修改指定位置为指定元素"><a href="#setElementAt-修改指定位置为指定元素" class="headerlink" title="setElementAt : 修改指定位置为指定元素"></a>setElementAt : 修改指定位置为指定元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setElementAt(E obj, int index) &#123;</span><br><span class="line">    if (index &gt;= elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">     // 数组就是方便，直接更新就好了</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setSize-修改数组容量"><a href="#setSize-修改数组容量" class="headerlink" title="setSize : 修改数组容量"></a>setSize : 修改数组容量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setSize(int newSize) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (newSize &gt; elementCount) &#123;</span><br><span class="line">        //元素个数超出容量就要扩容</span><br><span class="line">        ensureCapacityHelper(newSize);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //新增 elementCount - newSize 个元素</span><br><span class="line">        for (int i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">            elementData[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    elementCount = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sort-排序，修改顺序-用的是-Arrays-sort"><a href="#sort-排序，修改顺序-用的是-Arrays-sort" class="headerlink" title="sort : 排序，修改顺序 用的是 Arrays.sort"></a>sort : 排序，修改顺序 用的是 Arrays.sort</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void sort(Comparator&lt;? super E&gt; c) &#123;</span><br><span class="line">    final int expectedModCount = modCount;</span><br><span class="line">    // 用的是 Arrays.sort </span><br><span class="line">    Arrays.sort((E[]) elementData, 0, elementCount, c);</span><br><span class="line">    if (modCount != expectedModCount) &#123;</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trimToSize-将当前容量值设为-实际元素个数"><a href="#trimToSize-将当前容量值设为-实际元素个数" class="headerlink" title="trimToSize : 将当前容量值设为 = 实际元素个数"></a>trimToSize : 将当前容量值设为 = 实际元素个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void trimToSize() &#123;</span><br><span class="line">modCount++;</span><br><span class="line">int oldCapacity = elementData.length;</span><br><span class="line">if (elementCount &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, elementCount);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h3><h4 id="indexOf-从index位置开始向后查找元素-o"><a href="#indexOf-从index位置开始向后查找元素-o" class="headerlink" title="indexOf : 从index位置开始向后查找元素(o)"></a>indexOf : 从index位置开始向后查找元素(o)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int indexOf(Object o, int index) &#123;</span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="indexOf-查找-o-在数组中首次出现的位置"><a href="#indexOf-查找-o-在数组中首次出现的位置" class="headerlink" title="indexOf : 查找 o 在数组中首次出现的位置"></a>indexOf : 查找 o 在数组中首次出现的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    return indexOf(o, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="contains-是否包含-O"><a href="#contains-是否包含-O" class="headerlink" title="contains : 是否包含 O"></a>contains : 是否包含 O</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    return indexOf(o, 0) &gt;= 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="containsAll-是否包含整个集合"><a href="#containsAll-是否包含整个集合" class="headerlink" title="containsAll : 是否包含整个集合"></a>containsAll : 是否包含整个集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    //调用 AbstractCollection 的方法，使用迭代器挨个遍历查找，两重循环</span><br><span class="line">    return super.containsAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean containsAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">    for (Object e : c)</span><br><span class="line">        if (!contains(e))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="firstElement-获取Vector中的第一个元素"><a href="#firstElement-获取Vector中的第一个元素" class="headerlink" title="firstElement : 获取Vector中的第一个元素"></a>firstElement : 获取Vector中的第一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E firstElement() &#123;</span><br><span class="line">    if (elementCount == 0) &#123;</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return elementData(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lastElement-获取Vector中的最后一个元素"><a href="#lastElement-获取Vector中的最后一个元素" class="headerlink" title="lastElement : 获取Vector中的最后一个元素"></a>lastElement : 获取Vector中的最后一个元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E lastElement() &#123;</span><br><span class="line">    if (elementCount == 0) &#123;</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    return elementData(elementCount - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isEmpty-判断Vector是否为空"><a href="#isEmpty-判断Vector是否为空" class="headerlink" title="isEmpty : 判断Vector是否为空"></a>isEmpty : 判断Vector是否为空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean isEmpty() &#123;</span><br><span class="line">return elementCount == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="size-返回“Vector的实际大小”，即Vector中元素个数"><a href="#size-返回“Vector的实际大小”，即Vector中元素个数" class="headerlink" title="size :  返回“Vector的实际大小”，即Vector中元素个数"></a>size :  返回“Vector的实际大小”，即Vector中元素个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int size() &#123;</span><br><span class="line">return elementCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="capacity-返回“Vector的总的容量”"><a href="#capacity-返回“Vector的总的容量”" class="headerlink" title="capacity : 返回“Vector的总的容量”"></a>capacity : 返回“Vector的总的容量”</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int capacity() &#123;</span><br><span class="line">return elementData.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lastIndexOf-从后向前查找元素-o-。开始位置是从前向后的第index个数"><a href="#lastIndexOf-从后向前查找元素-o-。开始位置是从前向后的第index个数" class="headerlink" title="lastIndexOf : 从后向前查找元素(o)。开始位置是从前向后的第index个数"></a>lastIndexOf : 从后向前查找元素(o)。开始位置是从前向后的第index个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int lastIndexOf(Object o, int index) &#123;</span><br><span class="line">    if (index &gt;= elementCount)</span><br><span class="line">        throw new IndexOutOfBoundsException(index + &quot; &gt;= &quot;+ elementCount);</span><br><span class="line"></span><br><span class="line">    if (o == null) &#123;</span><br><span class="line">        for (int i = index; i &gt;= 0; i--)</span><br><span class="line">            if (elementData[i]==null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i = index; i &gt;= 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="elementAt-返回Vector中index位置的元素"><a href="#elementAt-返回Vector中index位置的元素" class="headerlink" title="elementAt : 返回Vector中index位置的元素"></a>elementAt : 返回Vector中index位置的元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public synchronized E elementAt(int index) &#123;</span><br><span class="line">    if (index &gt;= elementCount) &#123;</span><br><span class="line">        throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector-中的迭代器"><a href="#Vector-中的迭代器" class="headerlink" title="Vector 中的迭代器"></a>Vector 中的迭代器</h3><h4 id="普通迭代器-Iterator"><a href="#普通迭代器-Iterator" class="headerlink" title="普通迭代器　Iterator:"></a>普通迭代器　Iterator:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public synchronized Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    int cursor;       // index of next element to return</span><br><span class="line">    int lastRet = -1; // index of last element returned; -1 if no such</span><br><span class="line">    int expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        // 调用 next() 前的检查</span><br><span class="line">        return cursor != elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E next() &#123;</span><br><span class="line">        //注意了，Vector 连迭代器的方法也加了同步</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i = cursor;</span><br><span class="line">            if (i &gt;= elementCount)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            cursor = i + 1;</span><br><span class="line">            return elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        if (lastRet == -1)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        //注意了，Vector 连迭代器的方法也加了同步</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.this.remove(lastRet);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //大概看下这个 1.8 的方法</span><br><span class="line">    @Override</span><br><span class="line">    public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            final int size = elementCount;</span><br><span class="line">            int i = cursor;</span><br><span class="line">            if (i &gt;= size) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            final E[] elementData = (E[]) Vector.this.elementData;</span><br><span class="line">            if (i &gt;= elementData.length) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            while (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                action.accept(elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            // update once at end of iteration to reduce heap write traffic</span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - 1;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void checkForComodification() &#123;</span><br><span class="line">        if (modCount != expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; elementCount)</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);</span><br><span class="line">    return new ListItr(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;</span><br><span class="line">    ListItr(int index) &#123;</span><br><span class="line">        super();</span><br><span class="line">        cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasPrevious() &#123;</span><br><span class="line">        return cursor != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int nextIndex() &#123;</span><br><span class="line">        return cursor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int previousIndex() &#123;</span><br><span class="line">        return cursor - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public E previous() &#123;</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i = cursor - 1;</span><br><span class="line">            if (i &lt; 0)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            cursor = i;</span><br><span class="line">            return elementData(lastRet = i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set(E e) &#123;</span><br><span class="line">        if (lastRet == -1)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.this.set(lastRet, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        int i = cursor;</span><br><span class="line">        synchronized (Vector.this) &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            Vector.this.add(i, e);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = i + 1;</span><br><span class="line">        lastRet = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vector-还支持-Enumeration-迭代：返回“Vector中全部元素对应的Enumeration”"><a href="#Vector-还支持-Enumeration-迭代：返回“Vector中全部元素对应的Enumeration”" class="headerlink" title="Vector 还支持 Enumeration　迭代：返回“Vector中全部元素对应的Enumeration”"></a>Vector 还支持 Enumeration　迭代：返回“Vector中全部元素对应的Enumeration”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Enumeration&lt;E&gt; elements() &#123;</span><br><span class="line">    // 通过匿名类实现Enumeration</span><br><span class="line">     return new Enumeration&lt;E&gt;() &#123;</span><br><span class="line">         int count = 0;</span><br><span class="line"></span><br><span class="line">         // 是否存在下一个元素</span><br><span class="line">         public boolean hasMoreElements() &#123;</span><br><span class="line">             return count &lt; elementCount;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // 获取下一个元素</span><br><span class="line">         public E nextElement() &#123;</span><br><span class="line">             synchronized (Vector.this) &#123;</span><br><span class="line">                 if (count &lt; elementCount) &#123;</span><br><span class="line">                     return elementData(count++);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             throw new NoSuchElementException(&quot;Vector Enumeration&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Vector 特点</p><ul><li>底层由一个可以增长的数组组成</li><li>Vector 通过 capacity (容量) 和 capacityIncrement (增长数量) 来尽量少的占用空间</li><li>扩容时默认扩大两倍</li><li>最好在插入大量元素前增加 vector 容量，那样可以减少重新申请内存的次数</li><li>通过 iterator 和 lastIterator 获得的迭代器是 fail-fast 的</li><li>通过 elements 获得的老版迭代器 Enumeration 不是 fail-fast 的</li><li>同步类，每个方法前都有同步锁 synchronized</li><li>在 JDK 2.0 以后，经过优化，Vector 也加入了 Java 集合框架大家族</li></ul><p>Vector VS ArrayList</p><p>共同点：</p><ul><li>都是基于数组</li><li>都支持随机访问</li><li>默认容量都是 10</li><li>都有扩容机制</li></ul><p>区别：</p><ul><li>Vector 出生的比较早，JDK 1.0 就出生了，ArrayList JDK 1.2 才出来</li><li>Vector 比 ArrayList 多一种迭代器 Enumeration</li><li>Vector 是线程安全的，ArrayList 不是</li><li>Vector 默认扩容 2 倍，ArrayList 是 1.5</li></ul><p>如果没有线程安全的需求，一般推荐使用 ArrayList，而不是 Vector，因为每次都要获取锁，效率太低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(四) -- LinkedList</title>
    <link href="http://www.litede.cn/2019/10/28/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E5%9B%9B-LinkedList/"/>
    <id>http://www.litede.cn/2019/10/28/常用集合类-四-LinkedList/</id>
    <published>2019-10-28T05:58:31.000Z</published>
    <updated>2019-10-28T09:05:29.530Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外， LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列&gt; 表用作堆栈、队列或双端队列。</p></blockquote><blockquote><p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p><p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一 端）。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个链接列表，而其中至少一个线程从结构上修改了该列表，则它必须 &gt; 保持外部同步。（结构修改指添加或删除一个或多个元素的任何操作；仅设置元素的值不是结构修改。）这一般通过对自&gt; 然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法&gt; 来“包装”该列表。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示：</p></blockquote><blockquote><p>   List list = Collections.synchronizedList(new LinkedList(…));<br>此类的 iterator 和 listIterator 方法返回的迭代器是快速失败 的：在迭代器创建之后，如果从结构上对列表进行修&gt; 改，除非通过迭代器自身的 remove 或 add 方法，其他任何时间任何方式的修改，迭代器都将抛出 &gt; ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来不确定的时间任 意发生不确定行为的风险。</p></blockquote><blockquote><p>注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何硬性保证。快速失败&gt; 迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的方式是错误的，正确做&gt; 法是：迭代器的快速失败行为应该仅用于检测程序错误。</p></blockquote><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="LinkedList类定义"><a href="#LinkedList类定义" class="headerlink" title="LinkedList类定义"></a>LinkedList类定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">     extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">     implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。</p><p>LinkedList 实现 List 接口，能对它进行队列操作。</p><p>LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。</p><p>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。</p><p>LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。</p><p>LinkedList 是非同步的。</p><p><strong>为什么要继承自AbstractSequentialList</strong> ?</p><p>AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些骨干性函数。降低了List接口的复杂度。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。</p><p>此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。</p><h2 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 链表大小</span><br><span class="line">    transient int size = 0;</span><br><span class="line"></span><br><span class="line">// 首节点</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">// 尾节点</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>其中node节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  // Node节点</span><br><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        // 下一个节点</span><br><span class="line">        this.next = next;</span><br><span class="line">        // 上一个节点</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,linkedList采用了链表节点的方式实现,并且每个节点都有前驱和后驱节点</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>LinkedList 总共有 2 个构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        this();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><p>LinkedList 中与双向队列相关的几个方法为：offerFirst、offerLast、pollFirst、pollLast。</p><h3 id="offerFirst-将指定的元素插入此列表的开头"><a href="#offerFirst-将指定的元素插入此列表的开头" class="headerlink" title="offerFirst : 将指定的元素插入此列表的开头"></a>offerFirst : 将指定的元素插入此列表的开头</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean offerFirst(E e) &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;  //1</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //2</span><br><span class="line">    first = newNode; //3</span><br><span class="line">    if (f == null) //4</span><br><span class="line">        last = newNode; //5</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode; //6</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析linkFirst(E e):</p><ol><li>现将first赋值给f</li><li>创建新节点</li><li>将新节点指向第一个节点</li><li>判断之前的头结点是否为空</li><li>如果为空,之前是一个空的节点,此时将last=newNode,使得此时的linkedList的last=first=newNode</li><li>如果不为空,将之前的头结点设为第二节点</li></ol><h3 id="offerLast-将指定的元素插入此列表的结尾"><a href="#offerLast-将指定的元素插入此列表的结尾" class="headerlink" title="offerLast : 将指定的元素插入此列表的结尾"></a>offerLast : 将指定的元素插入此列表的结尾</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean offerLast(E e) &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将offerFirst中的first改为last,其余都一样</p><h3 id="pollFirst-检索并删除此列表的第一个元素"><a href="#pollFirst-检索并删除此列表的第一个元素" class="headerlink" title="pollFirst : 检索并删除此列表的第一个元素"></a>pollFirst : 检索并删除此列表的第一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    return (f == null) ? null : unlinkFirst(f); //1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    // assert f == first &amp;&amp; f != null;</span><br><span class="line">    final E element = f.item;</span><br><span class="line">    final Node&lt;E&gt; next = f.next;</span><br><span class="line">    f.item = null;</span><br><span class="line">    f.next = null; // help GC</span><br><span class="line">    first = next;</span><br><span class="line">    if (next == null)</span><br><span class="line">        last = null; // 2</span><br><span class="line">    else</span><br><span class="line">        next.prev = null; // 3</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果第一个元素为空,则返回null,否则 将第一个元素传入unlinkFirst(f);</li><li>如果原首节点也是最后一个节点,则将linkedList的last也置为null</li><li>如果原首节点不是最后一个节点,则将下一个节点中的上一个节点指针置为null</li></ol><h3 id="pollLast-检测并删除此列表的最后一个元素"><a href="#pollLast-检测并删除此列表的最后一个元素" class="headerlink" title="pollLast : 检测并删除此列表的最后一个元素"></a>pollLast : 检测并删除此列表的最后一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public E pollLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    return (l == null) ? null : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line">// 删除尾节点</span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    // assert l == last &amp;&amp; l != null;</span><br><span class="line">    final E element = l.item;</span><br><span class="line">    final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    l.item = null;</span><br><span class="line">    l.prev = null; // help GC</span><br><span class="line">    last = prev;</span><br><span class="line">    if (prev == null)</span><br><span class="line">        first = null;</span><br><span class="line">    else</span><br><span class="line">        prev.next = null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将pollFirst中的next改为prev,last改为first,其余都一样</p><h3 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        if (numNew == 0)</span><br><span class="line">            return false;</span><br><span class="line">        // 1  </span><br><span class="line">        // pred为节点的上节点指针,succ为节点的下节点指针</span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        if (index == size) &#123;</span><br><span class="line">            succ = null;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将c添加到linkedList中  因为是添加,所以只考虑上节点指针就可以了</span><br><span class="line">        for (Object o : a) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null);</span><br><span class="line">            if (pred == null)</span><br><span class="line">                first = newNode;</span><br><span class="line">            else</span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (succ == null) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>快速查找到index所在位置,并根据x的位置赋值next或prev(如果index小于size的一半,则证明next一定有值,反之则证明prev一定有值)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外， LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(三) -- ArrayList</title>
    <link href="http://www.litede.cn/2019/10/26/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%B8%89-ArrayList/"/>
    <id>http://www.litede.cn/2019/10/26/常用集合类-三-ArrayList/</id>
    <published>2019-10-26T06:15:54.000Z</published>
    <updated>2019-10-28T02:24:23.400Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ArrayList继承自<a href="http://www.litede.cn/2019/10/26/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%8C%20--%20AbstractList/#more">abstractList</a> 是线程不安全的。</strong></p><h1 id="ArrayList的创建"><a href="#ArrayList的创建" class="headerlink" title="ArrayList的创建"></a>ArrayList的创建</h1><h2 id="ArrayList内部的成员变量"><a href="#ArrayList内部的成员变量" class="headerlink" title="ArrayList内部的成员变量"></a>ArrayList内部的成员变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> （默认初始化长度）ps：实际是“延时初始化”（lazy init），后文详解</span><br><span class="line">  */</span><br><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> （共享空数组，为了追求效率）</span><br><span class="line">  */</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> （区别于EMPTY_ELEMENTDATA，使用默认构造方法时，默认使用此空数组，再配合DEFAULT_CAPACITY共同实现lazy init）</span><br><span class="line">  */</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line"> （集合数据真正存放的地方，所以对于ArrayList我们可以理解为提供了一组高效操作方法的数组。当集合的首个元素被添加时，把空集合DEFAULTCAPACITY_EMPTY_ELEMENTDATA扩展为DEFAULT_CAPACITY大小的集合，这就是lazy init，使用时才分配内存空间，目的是防止空间的浪费。）ps：transient 表示此变量不参与序列化</span><br><span class="line">  */</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line"> （数组大小）</span><br><span class="line">  */</span><br><span class="line">private int size;</span><br></pre></td></tr></table></figure><h2 id="ArrayList有三种构造器"><a href="#ArrayList有三种构造器" class="headerlink" title="ArrayList有三种构造器"></a>ArrayList有三种构造器</h2><ol><li>无参构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中 DEFAULTCAPACITY_EMPTY_ELEMENTDATA源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>由此可见,无参构造只是构建了一个空的ArrayList,此时size为0.</p><ol start="2"><li>指定了容量的构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &gt; 0) &#123;</span><br><span class="line">            this.elementData = new Object[initialCapacity];</span><br><span class="line">        &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>解析: initialCapacity为指定的容量</p><ul><li>如果大于0 则创建一个容量为initialCapacity的Object数组</li><li>如果等于0 则共享空数组，为了追求效率</li><li>如果小于0 抛出异常</li></ul><ol start="3"><li>构造一个包含指定元素的列表的构造器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        if ((size = elementData.length) != 0) &#123;</span><br><span class="line">            // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">            if (elementData.getClass() != Object[].class)</span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // replace with empty array.</span><br><span class="line">            this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>解析: 首先调用ArrayList的父类AbstractCollection的toArray()方法将c变为Object数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">        // Estimate size of array; be prepared to see more or fewer elements</span><br><span class="line">        Object[] r = new Object[size()];</span><br><span class="line">        Iterator&lt;E&gt; it = iterator();</span><br><span class="line">        for (int i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">            if (! it.hasNext()) // fewer elements than expected</span><br><span class="line">                return Arrays.copyOf(r, i);</span><br><span class="line">            r[i] = it.next();</span><br><span class="line">        &#125;</span><br><span class="line">        return it.hasNext() ? finishToArray(r, it) : r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后判断:</p><ul><li>假如此时数组的长度不等于0且其不是Object类,则将其拷贝然后赋值</li><li>假如数组长度等于0,则直接共享空数组.</li></ul><p>**但是准确的说这有个bug,这个bug在jdk9修复,bug产生原因后面详解。附上<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener">链接</a></p><h2 id="常用方法解析"><a href="#常用方法解析" class="headerlink" title="常用方法解析"></a>常用方法解析</h2><ol><li>trimToSize<br>trimToSize方法将当前list的容量修改为列表当前的大小,用来最大程度的减小list的存储空间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void trimToSize() &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        if (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == 0)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>解析: 如果list的size小于其容量,则根据其size是否为0选择将size赋值为0还是讲当前数组内容复制,容量为size小的的新数组返回给elementData.</p><ol start="2"><li>rangeCheck(int index)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">       if (index &gt;= size)</span><br><span class="line">           throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>检查index是否越界,越界则抛出异常</p><ol start="3"><li>get(int index)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        return elementData(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析: </p><p>① 检查数组是否越界<br>② 直接取出数组elementData相应位置index的元素并强转为E</p><ol start="4"><li>set(int index, E element)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>解析:<br>① 判断index是否越界</p><p>② 取到index位置的值作为原值</p><p>③ 设置该位置值为修改后的值</p><p>④ return原值</p><ol start="5"><li>add(E e)</li></ol><p>add方法用到了刚才说的懒加载(lazy init),先说一下思路,然后按照思路看源码更容易理解一些.</p><p>① 判断是否需要lazy init,如果需要就init</p><p>② 判断是否需要扩容,如果需要执行步骤③,否则执行步骤⑤</p><p>③ 扩容.日新数组长度=当前数组长度*1.5,并判断扩容后长度是否满足目标容量,不满足则新数组长度=目标容量.接着判断新数组长度是否超过阈值MAX_ARRAY_SIZE,超过则执行步骤④<br>④ 目标数组长度=如果目标数组长度&gt;MAX_ARRAY_SIZE?Integer.MAX_VALUE:MAX_ARRAY_SIZE</p><p>⑤ 扩容结束后,执行数据copy,从原数组copy到新数组</p><p>⑥ 在指定位置添加元素,是长度增加.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">         ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">         elementData[size++] = e;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line"> private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">         if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">             minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         ensureExplicitCapacity(minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">         modCount++;</span><br><span class="line"> </span><br><span class="line">         // overflow-conscious code</span><br><span class="line">         if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">             grow(minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> private void grow(int minCapacity) &#123;</span><br><span class="line">         // overflow-conscious code</span><br><span class="line">         int oldCapacity = elementData.length;</span><br><span class="line">         int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">         if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">             newCapacity = minCapacity;</span><br><span class="line">         if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">             newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">         // minCapacity is usually close to size, so this is a win:</span><br><span class="line">         elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">         if (minCapacity &lt; 0) // overflow</span><br><span class="line">             throw new OutOfMemoryError();</span><br><span class="line">         return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">             Integer.MAX_VALUE :</span><br><span class="line">             MAX_ARRAY_SIZE;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>这里解析一下ArrayList(MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8)</p><ul><li>为什么无法创建更大的数组？<br>Attempts to allocate larger arrays may result in OutOfMemoryError</li></ul><p>如果数组长度过大，可能出现的两种错误</p><p>OutOfMemoryError: Java heap space  堆区内存不足（这个可以通过设置JVM参数 -Xmx 来指定）。</p><p>OutOfMemoryError: Requested array size exceeds VM limit  超过了JVM虚拟机的最大限制，我的window64就是 Integer.MAX_VALUE-1 .</p><p>（这些内容涉及到JVM虚拟机知识，以后再进一步补充）</p><ul><li>为什么数组长度的最大值是Integer.MAX_VALUE - 8</li></ul><p>数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。</p><ul><li>对象头信息Object head words</li></ul><p>数组的对象头信息相较于其他Object，多了一个表示数组长度的信息。</p><p>具体的对象头内容，可以参考 JVM分析</p><ol start="6"><li>remove(int index)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line"></span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>1.越界检测</li><li>2.取出当前位置的元素</li><li>3.当前位置之后的所有元素整体前移一位置</li><li>4.最后位置置空，size–，返回删除的元素值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解析: 思路很简单，按元素删除（注意只删除从头开始第一个匹配值），遍历-&gt;匹配-&gt;删除<br> 值得注意的是，单独对null做特殊处理，按地址比较.</p><ol start="7"><li>removeAll(Collection&lt;?&gt; c) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        return batchRemove(c, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">        final Object[] elementData = this.elementData;</span><br><span class="line">        int r = 0, w = 0;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        try &#123;</span><br><span class="line">//遍历当前集合所有元素</span><br><span class="line">            for (; r &lt; size; r++)</span><br><span class="line">                if (c.contains(elementData[r]) == complement)</span><br><span class="line">//如果指定集合不包含该元素（即不应删除的，需要保留的），把当前元素移动到头部w位置（原头部元素因不符合条件，直接删除掉，这里覆盖也即删除），并把w标记移到下一位</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // Preserve behavioral compatibility with AbstractCollection,</span><br><span class="line">            // even if c.contains() throws.</span><br><span class="line">//这儿两种情况：</span><br><span class="line">//无异常r==size 不会进入这个if</span><br><span class="line">//有异常，则把因异常而未来得及比较的所有元素整体copy到w位置，并把w标记移位size - r（可以理解为还未比较的数量）</span><br><span class="line">            if (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">//这儿很好理解，w位置（该位置之前都是比较或者异常而需要保留的）之后的所有都是应该删除的。</span><br><span class="line">            if (w != size) &#123;</span><br><span class="line">                // clear to let GC do its work</span><br><span class="line">                for (int i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = null;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                size = w;</span><br><span class="line">                modified = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个比较麻烦,所以注解都在代码上面了</p><h1 id="如何保证ArrayList的线程安全"><a href="#如何保证ArrayList的线程安全" class="headerlink" title="如何保证ArrayList的线程安全"></a>如何保证ArrayList的线程安全</h1><ol><li><p>继承ArrayList,然后重写或按需求编写自己的方法,这些方法要写成synchronized,在这些synchromized的方法中调用ArrayList的方法</p></li><li><p>使用Collections.syncronizedList</p></li></ol><p>使用方法如下<br>假如你创建的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String,Object&gt;&gt; data=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</span><br></pre></td></tr></table></figure><p>那么为了解决这个线程安全问题你可以这么使用Collections.synchronizedList()，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String,Object&gt;&gt; data=Collections.synchronizedList(new ArrayList&lt;Map&lt;String,Object&gt;&gt;());</span><br></pre></td></tr></table></figure><p> 其他的都没变，使用的方法也几乎与ArrayList一样，大家可以参考下api文档；</p><p> 额外再说下 ArrayList与LinkedList；这两个都是接口List下的一个实现，用法都一样，但用的场所的有点不同，ArrayList适合于进行大量的随机访问的情况下使用，LinkedList适合在表中进行插入、删除时使用，二者都是非线程安全，解决方法同上（为了避免线程安全，以上采取的方法，特别是第二种，其实是非常损耗性能的）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ArrayList继承自&lt;a href=&quot;http://www.litede.cn/2019/10/26/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%8C%20--%20AbstractList/
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(二) -- AbstractList</title>
    <link href="http://www.litede.cn/2019/10/26/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%8C%20--%20AbstractList/"/>
    <id>http://www.litede.cn/2019/10/26/常用集合类-二 -- AbstractList/</id>
    <published>2019-10-26T06:07:33.000Z</published>
    <updated>2019-10-26T06:15:06.425Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ArrayList和LinkedList都继承自abstractList 都是线程不安全的。</strong></p><ul><li>abstractList 提供checkForComodification方法（next，add，remove方法中都有调用此方法），在单线程中，遍历的时候删除List（for循环和增强for循环都不是正确做法，迭代器遍历才是正确的，博客后面有例子声明）。当两个线程有冲突时，（当一个线程使用迭代器遍历的时候，另一线程add，remove时，都会改变modcount值。）会抛出ConcurrentModificationException异常。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void checkForComodification() &#123;</span><br><span class="line">    if (this.modCount != l.modCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ArrayList和LinkedList都继承自abstractList 都是线程不安全的。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;abstractList 提供checkForComodification方法（next，add，remove方法中都有
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用集合类(一) -- 综述</title>
    <link href="http://www.litede.cn/2019/10/26/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB(%E4%B8%80)/"/>
    <id>http://www.litede.cn/2019/10/26/常用集合类(一)/</id>
    <published>2019-10-26T02:32:04.000Z</published>
    <updated>2019-10-26T06:06:18.913Z</updated>
    
    <content type="html"><![CDATA[<p><strong>集合类在java开发中有着非常高的频率,它弥补了数组的缺陷,且比数组更灵活更实用,使用场景也比数组更广泛.所以选择合适的集合类对于性能的提升是很大的.</strong></p><p><img src="https://img-blog.csdnimg.cn/20191026103620175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><ol><li>介绍</li></ol><ul><li>Collection接口是可以理解成动态的数组和集合,与数组类似,但不同的是集合可以任意扩充大小</li><li>Collection是最基本的接口,如上图所示,List和Set类都是继承于它</li></ul><ol start="2"><li>特点</li></ol><ul><li>性能高</li><li>易扩展</li><li>易修改</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List接口及其实现类是容量可变的列表，可按索引访问集合中的元素。</p><ol><li>特点:</li></ol><ul><li>List接口可以存放任意的数据，且在接口中，内容可以重复</li><li>List中提供了高效的插入和移除多个元素的方法</li></ul><p>列表在数据结构中分别表现为：数组和向量、链表、堆栈、队列。</p><ol start="2"><li>List常用（实现）子类</li></ol><ul><li>ArrayList（实现类）</li></ul><p>ArrayList 数组结构，插入移除数据慢，查询数据快，按索引查找，不是线程安全的。</p><p>contains复杂度为O(n)，add复杂度为分摊的常数，即添加n个元素需要O(n)时间，remove为O(n)，get复杂度为O(1)</p><p>例：<figure class="highlight plain"><figcaption><span>list </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- LinkedList(实现类)</span><br><span class="line"></span><br><span class="line">LinkedList 链表结构，插入移除数据块，只需要替换首尾节点地址就行，查询数据慢，需要按列表节点顺序依次查找。不是线程安全,可以当作堆栈、队列、双向队列来使用.</span><br><span class="line">例: ist list1=new LinkedList();</span><br><span class="line"></span><br><span class="line">- Vector（实现类）</span><br><span class="line"></span><br><span class="line">Vector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高,，有序，可重复，。Vector是线程安全的。</span><br><span class="line"></span><br><span class="line">例：```List list = new Vector&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>ArrayList 和 Vector 的区别：<br>（1）：Vector是线程安全的，源码中有很多的synchronized可以看出，而ArrayList不是。导致Vector效率无法和ArrayList相比； </p><p>（2）：ArrayList和Vector都采用线性连续存储空间，当存储空间不足的时候，ArrayList默认增加为原来的50%，Vector默认增加为原来的一倍； </p><p>（3）：Vector可以设置capacityIncrement，而ArrayList不可以，从字面理解就是capacity容量，Increment增加，容量增长的参数。</p><ol start="3"><li>使用场景</li></ol><ul><li>对于需要快速插入、删除元素，应该使用LinkedList</li><li>对于需要快速随机访问元素，应该使用ArrayList</li><li>如果List需要被多线程操作，应该使用Vector，如果只会被单线程操作，应该使用ArrayList</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set接口可以存放任意的数据，且在接口中，<strong>数据不可以重复</strong>（注意和List进行区别）</p><ol><li>特点</li></ol><ul><li>无序</li><li>不重复</li><li>HashSet 能够快速定位一个元素。存入HashSet中的对象必须实现HashCode方法</li></ul><ol start="2"><li>常用实现类</li></ol><ul><li>HashSet</li></ul><p>HashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。</p><figure class="highlight plain"><figcaption><span>sets</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- TreeSet</span><br><span class="line"></span><br><span class="line">TreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。</span><br><span class="line"></span><br><span class="line">``` Set sets=new TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>HashSet和TreeSet的区别:</p><ul><li>HashSet与TreeSet都是间接实现了Set接口，同样拥有add、remove等方法</li><li>HashSet是无序存放的、而TreeSet实现是有序存放（ASCII顺序存放）</li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是一种把键对象和值对象进行关联的一种容器。</p><ol><li>特点: </li></ol><ul><li>数据是以键值对的形式存放，例如：</li></ul><p>key -&gt; value</p><p>“name” -&gt; “尼古拉斯赵四”</p><ul><li>key不允许重复。</li><li>键（key）的类型要一致，值（value）的类型也要一致。</li></ul><ol start="2"><li>常用实现类</li></ol><ul><li>HashMap</li></ul><p>HashMap 实现一个键到值映射的哈希表，通过键取得对象，没有顺序，通过get(key)来获取value，允许存储空对象，而且允许键是空(由于键必须是唯一，当然只能有一个)。</p><p>HashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。</p><p>HashMap允许key、value值为null。HashMap是非线程安全的。</p><p>初始化代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; maps = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">maps.put(&quot;name&quot;,&quot;詹姆斯刘能&quot;);</span><br><span class="line"></span><br><span class="line">maps.put(&quot;age&quot;,&quot;24&quot;);</span><br></pre></td></tr></table></figure><ul><li>HashTable</li></ul><p>HashTable 实现一个映像，所有的键必须非空，线程安全。如果处理的数据比较大，可以考虑concurrentHashMap,采用分片加锁，提高程序运行效率。</p><p>HashMap与HashSet:</p><ol><li>Hashtable是HashMap的线程安全版本。而且，key、value都不允许为null。</li><li>Hashtable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li></ol><ul><li>TreeMap </li></ul><p>TreeMap 实现排序。</p><ul><li>ConcurrentHashMap </li></ul><p>ConcurrentHashMap 线程安全，比hashtable效率高，内部实现是分片锁定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;集合类在java开发中有着非常高的频率,它弥补了数组的缺陷,且比数组更灵活更实用,使用场景也比数组更广泛.所以选择合适的集合类对于性能的提升是很大的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中各种关键字</title>
    <link href="http://www.litede.cn/2019/10/26/Java%E4%B8%AD%E5%90%84%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.litede.cn/2019/10/26/Java中各种关键字/</id>
    <published>2019-10-26T00:55:57.000Z</published>
    <updated>2019-10-26T01:21:33.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h1><h2 id="transient的作用及使用方法"><a href="#transient的作用及使用方法" class="headerlink" title="transient的作用及使用方法"></a>transient的作用及使用方法</h2><p>java中的transient关键字为我们提供了便利,只需要实现Serilizable接口,将不需要序列化的属性前天健关键字transient,序列化对象的时候,这个属性就不会序列化到指定的目的地中.</p><p>示例code如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 使用transient关键字不序列化某个变量</span><br><span class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span><br><span class="line"> *        </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date  2013-10-15</span><br><span class="line"> */</span><br><span class="line">public class TransientTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;Alexia&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;C:/user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;C:/user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    private String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: 123456</span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: Alexia</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure><p>密码字段为null，说明反序列化时根本没有从文件中获取到信息。</p><h2 id="transient使用小结"><a href="#transient使用小结" class="headerlink" title="transient使用小结"></a>transient使用小结</h2><ol><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</li><li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li></ol><p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description 使用transient关键字不序列化某个变量</span><br><span class="line"> *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致</span><br><span class="line"> *        </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date  2013-10-15</span><br><span class="line"> */</span><br><span class="line">public class TransientTest &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(&quot;Alexia&quot;);</span><br><span class="line">        user.setPasswd(&quot;123456&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;read before Serializable: &quot;);</span><br><span class="line">        System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">        System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream os = new ObjectOutputStream(</span><br><span class="line">                    new FileOutputStream(&quot;C:/user.txt&quot;));</span><br><span class="line">            os.writeObject(user); // 将User对象写进文件</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 在反序列化之前改变username的值</span><br><span class="line">            User.username = &quot;jmwang&quot;;</span><br><span class="line">            </span><br><span class="line">            ObjectInputStream is = new ObjectInputStream(new FileInputStream(</span><br><span class="line">                    &quot;C:/user.txt&quot;));</span><br><span class="line">            user = (User) is.readObject(); // 从流中读取User的数据</span><br><span class="line">            is.close();</span><br><span class="line">            </span><br><span class="line">            System.out.println(&quot;\nread after Serializable: &quot;);</span><br><span class="line">            System.out.println(&quot;username: &quot; + user.getUsername());</span><br><span class="line">            System.err.println(&quot;password: &quot; + user.getPasswd());</span><br><span class="line">            </span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 8294180014912103005L;  </span><br><span class="line">    </span><br><span class="line">    public static String username;</span><br><span class="line">    private transient String passwd;</span><br><span class="line">    </span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getPasswd() &#123;</span><br><span class="line">        return passwd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setPasswd(String passwd) &#123;</span><br><span class="line">        this.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><figcaption><span>before Serializable: </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">username: Alexia</span><br><span class="line">password: 123456</span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: jmwang</span><br><span class="line">password: null</span><br></pre></td></tr></table></figure><p>这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。</p><h2 id="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？"><a href="#transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？" class="headerlink" title="transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？"></a>transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？</h2><p>思考下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.io.Externalizable;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.ObjectInput;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutput;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @descripiton Externalizable接口的使用</span><br><span class="line"> * </span><br><span class="line"> * @author Alexia</span><br><span class="line"> * @date 2013-10-15</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class ExternalizableTest implements Externalizable &#123;</span><br><span class="line"></span><br><span class="line">    private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeExternal(ObjectOutput out) throws IOException &#123;</span><br><span class="line">        out.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void readExternal(ObjectInput in) throws IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        content = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        ExternalizableTest et = new ExternalizableTest();</span><br><span class="line">        ObjectOutput out = new ObjectOutputStream(new FileOutputStream(</span><br><span class="line">                new File(&quot;test&quot;)));</span><br><span class="line">        out.writeObject(et);</span><br><span class="line"></span><br><span class="line">        ObjectInput in = new ObjectInputStream(new FileInputStream(new File(</span><br><span class="line">                &quot;test&quot;)));</span><br><span class="line">        et = (ExternalizableTest) in.readObject();</span><br><span class="line">        System.out.println(et.content);</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是：</p><blockquote><p>是的，我将会被序列化，不管我是否被transient关键字修饰</p></blockquote><p>这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？</p><p> 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序化将会自动进行，<strong>若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExterna方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关</strong>。因此第二个例子输出的是变content初始化的内容，而不是null。</p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p> final 在 Java 中是一个保留的关键字，可以声明变量、方法、类。</p><ol><li><p>当用 final 修饰一个类时，表明这个类不能被继承。</p></li><li><p>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。final方法是静态绑定的，在编译时候就确定是哪个类的方法，所以比非final方法快一些。</p></li><li><p>final修饰的常量普通变量不可变，修饰的引用变量不可变，引用对象的内容可以改变。</p><p>使用final的优点：<br>final方法比非final快一些<br>final关键字提高了性能。JVM和Java应用都会缓存final变量。<br>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。<br>使用final关键字，JVM会对方法、变量及类进行优化。</p></li></ol><p><a href="https://mp.weixin.qq.com/s/8tjS5J8Qan3dtEQxJ7WxgA" target="_blank" rel="noopener">final关键字图解</a></p><h1 id="Override的作用"><a href="#Override的作用" class="headerlink" title="Override的作用"></a>Override的作用</h1><p>@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处:</p><ol><li>可以当注释用,方便阅读；</li><li>编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。</li></ol><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p><strong>异常处理的执行顺序（针对try{}catch{}finally{}而言）<br>对于try{}catch{}finally{}而言，它们的执行顺序很简单，如果在try{}中捕获相应的异常，中断当前代码的执行，转而去执行catch{}中的内容，最后去执行 finally{}中方法，一般来说finally中的方法都是会被执行的，其中finally中很大程度上用于资源的释放。</strong></p><p>下面讲解一些我们java程序员需要注意的地方。</p><ol><li>finally中的代码总是会执行吗？</li></ol><p>答：no，如果一个方法内在执行try{}语句之前就已经return了，那么finally语句指定不会执行了。因为它根本没有进入try语句中如果在一个try语句中调用System.exit(0);方法，那么就会退出当前java虚拟机，那么finally也就没有执行的机会了。</p><ol start="2"><li>finally在return之前执行还是在return之后执行？<br>答：很多人可能会说在return执行之前执行。我的答案是在return中间执行，是不是很特别。具体参见[java中finally执行顺序]{<a href="https://www.cnblogs.com/xiohao/p/4278405.html}" target="_blank" rel="noopener">https://www.cnblogs.com/xiohao/p/4278405.html}</a></li></ol><p>观察以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package FileUtil;</span><br><span class="line"></span><br><span class="line">public class finallyTest &#123;</span><br><span class="line">    public static int method()&#123;</span><br><span class="line">        int x=1;</span><br><span class="line">        try&#123;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            ++x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int method2()&#123;</span><br><span class="line">        int x=1;</span><br><span class="line">        try&#123;</span><br><span class="line">            return x++;</span><br><span class="line">        &#125;catch(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            return ++x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(method());//1</span><br><span class="line">        System.out.println(method2());//3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出分别是1和3。</p><p>method()：首先程序在执行到try{}语句中的return方法后，就会先返回相应的值，并把相应的值存储在一个临时栈中去保存这个结果。这时临时栈中存储的值为1。但是程序不会立刻返回，转而回去执行finally中的方法，++x，在finally执行完后，方法全部执行完，这时会再次调用return方法，注意这时 不在是返回值，而是告诉主调程序，被调程序已经执行完了，你可以接着去执行你主程序的其它方法了。但是请注意，此时返回的值还是原来保存在临时栈中的值1。<br>method2():这里在try{}语句中执行到return会在临时栈中存储值返回值的变量。接着回去执行finally里面的内容，这时执行finally中的return方法，这时 临时栈中的值就是变为 3，会覆盖原来临时栈中的值1.所以它的返回值为3。</p><hr><p>转载作者: <a href="https://blog.csdn.net/qq_43502142/article/details/88815710" target="_blank" rel="noopener">https://blog.csdn.net/qq_43502142/article/details/88815710</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;transient&quot;&gt;&lt;a href=&quot;#transient&quot; class=&quot;headerlink&quot; title=&quot;transient&quot;&gt;&lt;/a&gt;transient&lt;/h1&gt;&lt;h2 id=&quot;transient的作用及使用方法&quot;&gt;&lt;a href=&quot;#transien
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java中几种常量池</title>
    <link href="http://www.litede.cn/2019/10/26/Java%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <id>http://www.litede.cn/2019/10/26/Java中几种常量池/</id>
    <published>2019-10-26T00:35:53.000Z</published>
    <updated>2019-10-26T00:54:15.154Z</updated>
    
    <content type="html"><![CDATA[<p>在java的内存分配中,经常听到很多关于常量池的描述,我开始看的时候也是看的很模糊,网上五花八门的说法太多了,最后查阅&lt;&lt;深入了解JAVA虚拟机&gt;&gt;,差不多是理清了,很多网上说法都是有问题的,下面我就来区分一下这几个概念.</p><h1 id="全局字符串池-String-pool也叫做string-literal-pool"><a href="#全局字符串池-String-pool也叫做string-literal-pool" class="headerlink" title="全局字符串池(String pool也叫做string literal pool)"></a>全局字符串池(String pool也叫做string literal pool)</h1><p>全局字符串池里的内容是在类加载完成,经过验证.,准备阶段之后在<strong>堆</strong>中生成的字符串对象实例,然后将该字符串对象实例的引用值存到string pool中(<strong>记住:string pool中村的是引用值而不是具体的实例对象,具体的实例对象实在对中开辟的一块内存空间存放的</strong>).</p><p>在HotSpot VM里实现的string pool功能的是一个StringTable类,它是一个哈希表,里面存的是驻留字符串(也就是我们常说的用双括号引起来的)的引用(而不是驻留字符串实例本身),也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份.这个StringTable在每个HotSpot VM的实例只有一份,被所有的类共享.</p><h1 id="class文件常量池-class-constant-pool"><a href="#class文件常量池-class-constant-pool" class="headerlink" title="class文件常量池(class constant pool)"></a>class文件常量池(class constant pool)</h1><p>我们都知道,class文件中除了包含类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池(constant pool table),用于存放编译器生成的<strong>各种字面量(Literal)和符号引用(Symbolic References)</strong>.</p><p>字面量就是我们常说的<strong>常量</strong>概念,如文本字符串,被声明的final的常量值等.</p><p><strong>符号引用</strong>是一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义的定位到目标即可(它与直接引用区分一下,直接引用一般是指向方法区的本地指针,相对于偏移量或是一个能间接定位到目标的句柄).一般包括下面三类常量:</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池的每一项常量就是一个表,一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2kxMzcyLnBob3RvYnVja2V0LmNvbS9hbGJ1bXMvYWczMzMvRW1hbnVlbGluZy9ibG9nLzIwMTUtNy0yOC9jb25zdGFudC10YWJsZS1pbmZvX3pwc3FldGVta2cwLnBuZw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>每种不同类型的常量类型具有不同的结构，具体的结构本文就先不叙述了，本文着重区分这三个常量池的概念（读者若想深入了解每种常量类型的数据结构可以查看《深入理解java虚拟机》第六章的内容）。</p><h1 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h1><p>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？</p><p>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</p><p>举个实例来说明一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abc&quot;;</span><br><span class="line">String str2 = new String(&quot;def&quot;);</span><br><span class="line">String str3 = &quot;abc&quot;;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = &quot;def&quot;;</span><br><span class="line">System.out.println(str1 == str3);//true</span><br><span class="line">System.out.println(str2 == str4);//false</span><br><span class="line">System.out.println(str4 == str5);//true</span><br></pre></td></tr></table></figure><p>上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。</p><p>回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。</li><li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li><li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在java的内存分配中,经常听到很多关于常量池的描述,我开始看的时候也是看的很模糊,网上五花八门的说法太多了,最后查阅&amp;lt;&amp;lt;深入了解JAVA虚拟机&amp;gt;&amp;gt;,差不多是理清了,很多网上说法都是有问题的,下面我就来区分一下这几个概念.&lt;/p&gt;
&lt;h1 id=&quot;全
      
    
    </summary>
    
    
      <category term="jvm" scheme="http://www.litede.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="http://www.litede.cn/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 两个对象不同为什么他们的hashcode有可能相同</title>
    <link href="http://www.litede.cn/2019/10/25/JAVA-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%90%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%96%E4%BB%AC%E7%9A%84hashcode%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9B%B8%E5%90%8C/"/>
    <id>http://www.litede.cn/2019/10/25/JAVA-两个对象不同为什么他们的hashcode有可能相同/</id>
    <published>2019-10-25T09:43:55.000Z</published>
    <updated>2019-10-25T09:47:45.093Z</updated>
    
    <content type="html"><![CDATA[<p><strong>哈希表是结合了直接寻址和链式寻址两种方式，所需要的就是将需要加入哈希表的数据首先计算哈希值，其实就是预先分个组，然后再将数据挂到分组后的链表后面，随着添加的数据越来越多，分组链上会挂接更多的数据，同一个分组链上的数据必定具有相同的哈希值，java中的hash函数返回的是int类型的，也就是说，最多允许存在2^32个分组，也是有限的，所以出现相同的哈希码就不稀奇了</strong></p><p>这段话简易来说就是,hash算法不能为每一条数据分配一个独有的hashcode值,因此会有重复.<br>比如:</p><p>比如说你用身份证判断equal, hashcode = 身份证每一位的数字的综合。</p><p>甲的身份证是 12345</p><p>乙的身份证是 54321</p><p>这样甲和乙的hashcode 都是以一样的 1 + 2+ 3+ 4+ 5 = 15<br>但是 12345 不equals 54321</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;哈希表是结合了直接寻址和链式寻址两种方式，所需要的就是将需要加入哈希表的数据首先计算哈希值，其实就是预先分个组，然后再将数据挂到分组后的链表后面，随着添加的数据越来越多，分组链上会挂接更多的数据，同一个分组链上的数据必定具有相同的哈希值，java中的hash
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Switch对String的支持</title>
    <link href="http://www.litede.cn/2019/10/25/Switch%E5%AF%B9String%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <id>http://www.litede.cn/2019/10/25/Switch对String的支持/</id>
    <published>2019-10-25T08:37:51.000Z</published>
    <updated>2019-10-25T09:49:45.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="switch对整型的支持"><a href="#switch对整型的支持" class="headerlink" title="switch对整型的支持"></a>switch对整型的支持</h1><p>先看一段简单的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int i = 3;</span><br><span class="line"></span><br><span class="line">       switch (i) &#123;</span><br><span class="line">           case 1:</span><br><span class="line">               System.out.println(1);</span><br><span class="line">               break;</span><br><span class="line">           case 3:</span><br><span class="line">               System.out.println(3);</span><br><span class="line">               break;</span><br><span class="line">           default:</span><br><span class="line">               System.out.println(&quot;error&quot;);</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>输出: 3</p><p>反编译后代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int i = 3;</span><br><span class="line">        switch(i) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            System.out.println(1);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            System.out.println(3);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码基本相同,由此可见,<strong><em>Switch对整型的判断是直接整数的值</em></strong></p><h1 id="Switch对字符型的支持"><a href="#Switch对字符型的支持" class="headerlink" title="Switch对字符型的支持"></a>Switch对字符型的支持</h1><p>先看一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char a = &apos;b&apos;;</span><br><span class="line">        </span><br><span class="line">        switch (a) &#123;</span><br><span class="line">            case &apos;a&apos;:</span><br><span class="line">                System.out.println(&apos;a&apos;);</span><br><span class="line">                break;</span><br><span class="line">            case &apos;b&apos;:</span><br><span class="line">                System.out.println(&apos;b&apos;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>编译后代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char a = 98;</span><br><span class="line">        switch(a) &#123;</span><br><span class="line">        case 97:</span><br><span class="line">            System.out.println(&apos;a&apos;);</span><br><span class="line">            break;</span><br><span class="line">        case 98:</span><br><span class="line">            System.out.println(&apos;b&apos;);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            System.out.println(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>由上可见,对char类型的比较,实际上是比较的<strong>ascii码</strong>,编译器会把char变量转换成对应的int变量比较</p><h1 id="switch对字符串的支持"><a href="#switch对字符串的支持" class="headerlink" title="switch对字符串的支持"></a>switch对字符串的支持</h1><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;world&quot;;</span><br><span class="line">        </span><br><span class="line">        switch (str) &#123;</span><br><span class="line">            case &quot;hello&quot;:</span><br><span class="line">                System.out.println(&quot;hello&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;world&quot;:</span><br><span class="line">                System.out.println(&quot;world&quot;);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对代码反编译:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;world&quot;;</span><br><span class="line">byte var3 = -1;</span><br><span class="line">switch(str.hashCode()) &#123;</span><br><span class="line">case 99162322:</span><br><span class="line">    if (str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">        var3 = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">case 113318802:</span><br><span class="line">    if (str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">        var3 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(var3) &#123;</span><br><span class="line">case 0:</span><br><span class="line">    System.out.println(&quot;hello&quot;);</span><br><span class="line">    break;</span><br><span class="line">case 1:</span><br><span class="line">    System.out.println(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可见,switch对于字符串的支持是通过equals()和hashcode()实现的.因为switch的判断条件只能是等于，所以对于数据类型的精度要求比较高,所以<strong>Switch表达式中只能是整形</strong>,比如byte,short,char和int.所以<br><strong>switch中使用hashcode值</strong>,但是众所周知,<a href="http://www.litede.cn/2019/10/25/JAVA-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%90%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%96%E4%BB%AC%E7%9A%84hashcode%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9B%B8%E5%90%8C/">不同的值对应的hashcode有可能相同</a>,所以,在switch方法体中,还需要使用<strong>equals()</strong>来进行最后的确认.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>switch表达式只支持一种类型:整型</strong>,所以</p><ul><li>char要转换成对应的ascii码</li><li>string要转成对应的hashcode值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;switch对整型的支持&quot;&gt;&lt;a href=&quot;#switch对整型的支持&quot; class=&quot;headerlink&quot; title=&quot;switch对整型的支持&quot;&gt;&lt;/a&gt;switch对整型的支持&lt;/h1&gt;&lt;p&gt;先看一段简单的源码:&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String类常用方法源码分析</title>
    <link href="http://www.litede.cn/2019/10/24/String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.litede.cn/2019/10/24/String类常用方法源码分析/</id>
    <published>2019-10-24T05:48:58.000Z</published>
    <updated>2019-10-25T08:06:33.683Z</updated>
    
    <content type="html"><![CDATA[<p>环境: JDK8</p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>先看String类的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br></pre></td></tr></table></figure><p>可以看到String类被final修饰,因此不能被继承.String类还实现了序列化接口Serializable,可比较的接口Comparable并指定泛型String,该接口必须实现int compareTo方法,最后还实现了字符序列CharSequence的接口,该接口常用的方法如chatAt(int index),length(),toString()等等.</p><h1 id="构造字符串"><a href="#构造字符串" class="headerlink" title="构造字符串"></a>构造字符串</h1><p>String类的无参构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Initializes a newly created &#123;@code String&#125; object so that it represents</span><br><span class="line">     * an empty character sequence.  Note that use of this constructor is</span><br><span class="line">     * unnecessary since Strings are immutable.</span><br><span class="line">     */</span><br><span class="line">public String() &#123;</span><br><span class="line">        this.value = &quot;&quot;.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中value定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** The value is used for character storage. */</span><br><span class="line">   private final char value[];</span><br></pre></td></tr></table></figure><p>该构造函数创建了一个空的字符换并存在字符数组value中.</p><p>再看看一个有参的构造函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Allocates a new &#123;@code String&#125; so that it represents the sequence of</span><br><span class="line">     * characters currently contained in the character array argument. The</span><br><span class="line">     * contents of the character array are copied; subsequent modification of</span><br><span class="line">     * the character array does not affect the newly created string.</span><br><span class="line">     *</span><br><span class="line">     * @param  value</span><br><span class="line">     *         The initial value of the string</span><br><span class="line">     */</span><br><span class="line">    public String(char value[]) &#123;</span><br><span class="line">        this.value = Arrays.copyOf(value, value.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>该构造函数指定一个字符数组来创建一个字符序列,是通过Arrays的copyOf方法将字符数组拷贝到当前数组.</li></ol><p><strong>这样当修改字符数组的子串时,不会影响新字符数组.</strong></p><p>下面经过一个简单的测试来验证下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       char[] c1 = &#123;&apos;a&apos;, &apos;b&apos;&#125;;</span><br><span class="line">       char[] c2 = c1;</span><br><span class="line">       for (int i = 0; i &lt; c1.length; i++) &#123;</span><br><span class="line">           if (i==1)&#123;</span><br><span class="line">               c1[1]=&apos;c&apos;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (char c : c1) &#123;</span><br><span class="line">           System.out.println(&quot;c1:&quot;+c);</span><br><span class="line">       &#125;</span><br><span class="line">       for (char c : c2) &#123;</span><br><span class="line">           System.out.println(&quot;c2:&quot;+c);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1:a</span><br><span class="line">c1:c</span><br><span class="line">c2:a</span><br><span class="line">c2:c</span><br></pre></td></tr></table></figure><p>由上可知,在c1赋值给c2后,改变了c1中的值c2的值也会随之变化,这显然与我们想要的相悖,所以才会使用拷贝的方式,将c1与c2分开.</p><p>经过以上分析可以看出,下面两个语句是等价的,因为String类底层使用char[]数组来存储字符序列.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;</span><br><span class="line">String str = new String(data);</span><br></pre></td></tr></table></figure><ol start="2"><li>string.value.length的代码等价于string.length<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int length() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="使用字节数组构造一个String"><a href="#使用字节数组构造一个String" class="headerlink" title="使用字节数组构造一个String"></a>使用字节数组构造一个String</h1><p>在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。</p><p>String(byte[] bytes, Charset charset) 是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。</p><p>这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式。</p><p>如果我们在使用byte[]构造String的时候，使用的是下面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static byte[] encode(String charsetName, char[] ca, int off, int len)</span><br><span class="line">        throws UnsupportedEncodingException</span><br><span class="line">    &#123;</span><br><span class="line">        StringEncoder se = deref(encoder);</span><br><span class="line">        String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName;</span><br><span class="line">        if ((se == null) || !(csn.equals(se.requestedCharsetName())</span><br><span class="line">                              || csn.equals(se.charsetName()))) &#123;</span><br><span class="line">            se = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Charset cs = lookupCharset(csn);</span><br><span class="line">                if (cs != null)</span><br><span class="line">                    se = new StringEncoder(cs, csn);</span><br><span class="line">            &#125; catch (IllegalCharsetNameException x) &#123;&#125;</span><br><span class="line">            if (se == null)</span><br><span class="line">                throw new UnsupportedEncodingException (csn);</span><br><span class="line">            set(encoder, se);</span><br><span class="line">        &#125;</span><br><span class="line">        return se.encode(ca, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是编码清单，下面是解码清单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static char[] decode(String charsetName, byte[] ba, int off, int len)</span><br><span class="line">        throws UnsupportedEncodingException</span><br><span class="line">    &#123;</span><br><span class="line">        StringDecoder sd = deref(decoder);</span><br><span class="line">        String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName;</span><br><span class="line">        if ((sd == null) || !(csn.equals(sd.requestedCharsetName())</span><br><span class="line">                              || csn.equals(sd.charsetName()))) &#123;</span><br><span class="line">            sd = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                Charset cs = lookupCharset(csn);</span><br><span class="line">                if (cs != null)</span><br><span class="line">                    sd = new StringDecoder(cs, csn);</span><br><span class="line">            &#125; catch (IllegalCharsetNameException x) &#123;&#125;</span><br><span class="line">            if (sd == null)</span><br><span class="line">                throw new UnsupportedEncodingException(csn);</span><br><span class="line">            set(decoder, sd);</span><br><span class="line">        &#125;</span><br><span class="line">        return sd.decode(ba, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h2><p>再看charAt（int index）方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public char charAt(int index) &#123;</span><br><span class="line">        if ((index &lt; 0) || (index &gt;= value.length)) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(index);</span><br><span class="line">        &#125;</span><br><span class="line">        return value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回字符序列中下标为index的字符。并且index的范围：(0,value.length].</p><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>先看源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String concat(String str) &#123;</span><br><span class="line">        int otherLen = str.length(); //取得str字符串长度</span><br><span class="line">        if (otherLen == 0) &#123; //如果传入的字符串内容为空，则返回原字符串</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = value.length; //取得原字符串内容的长度</span><br><span class="line">        char buf[] = Arrays.copyOf(value, len + otherLen); //复制字符串的内容到char数组，并扩展长度</span><br><span class="line">        str.getChars(buf, len); //将str的内容复制到buf数组中，位置从len开始。在这一步完成两个字符串的拼接</span><br><span class="line">        return new String(buf, true); //将buf数组转化为新的String实例并返回</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>步骤含义基本都在上面,这里着重描述一下getChars方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void getChars(char dst[], int dstBegin) &#123;</span><br><span class="line">        System.arraycopy(value, 0, dst, dstBegin, value.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出,链接字符换操作实际是字符串的拷贝.最后返回连接成功后的字符串.</p><p>最后是一个特殊的私有包范围类型的构造方法，String除了提供了很多公有的供程序员使用的构造方法以外，还提供了一个包范围类型的构造方法（Jdk 8），我们看一下他是怎么样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(char[] value, boolean share) &#123;</span><br><span class="line">        // assert share : &quot;unshared not supported&quot;;</span><br><span class="line">        this.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，该方法和 String(char[] value)有两点区别：</p><ol><li><p>第一个，该方法多了一个参数： boolean share，其实这个参数在方法体中根本没被使用，也给了注释，目前不支持使用false，只使用true。那么可以断定，加入这个share的只是为了区分于String(char[] value)方法，不加这个参数就没办法定义这个函数，只有参数不能才能进行重载。</p></li><li><p>第二个区别就是具体的方法实现不同。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20191024145625743.png" alt="在这里插入图片描述"><br>那么也就是说，这个方法构造出来的String和参数传过来的char[] value共享同一个数组。 那么，为什么Java会提供这样一个方法呢？</p><p> 首先，我们分析一下使用该构造函数的好处：</p><ol><li>首先，性能好，这个很简单，一个是直接给数组赋值（相当于直接将String的value的指针指向char[]数组），一个是逐一拷贝。当然是直接赋值快了。</li></ol><ol start="2"><li><p>其次，共享内部数组节约内存。</p></li><li><p>该方法之所以设置为包范围，是因为一旦该方法设置为公有，在外面可以访问的话，那就破坏了字符串的不可变性。</p></li></ol><h2 id="subString"><a href="#subString" class="headerlink" title="subString"></a>subString</h2><p>substring有两个重载方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen = value.length - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex, int endIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        if (endIndex &gt; value.length) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen = endIndex - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">        return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this</span><br><span class="line">                : new String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两个重载方法都是先计算要截取的子串长度，判断边界最后返回调用new String(value, beginIndex, subLen)方法，我们来看一下这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &lt;= 0) &#123;</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            if (offset &lt;= value.length) &#123;</span><br><span class="line">                this.value = &quot;&quot;.value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">        if (offset &gt; value.length - count) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>offset指第一个匹配的字符序列的索引，count指子串的长度。<br>最终该子串会被拷贝到字符数组value中，并且后续的字符数组的修改并不影响新创建的字符串。</p><h2 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h2><p>先看一下源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean contains(CharSequence s) &#123;</span><br><span class="line">        return indexOf(s.toString()) &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出,直接调用indexOf方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(String str) &#123;</span><br><span class="line">        return indexOf(str, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(String str, int fromIndex) &#123;</span><br><span class="line">      return indexOf(value, 0, value.length,</span><br><span class="line">              str.value, 0, str.value.length, fromIndex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static int indexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">            char[] target, int targetOffset, int targetCount,</span><br><span class="line">            int fromIndex) &#123;</span><br><span class="line">        if (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">            return (targetCount == 0 ? sourceCount : -1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (fromIndex &lt; 0) &#123;</span><br><span class="line">            fromIndex = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (targetCount == 0) &#123;</span><br><span class="line">            return fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        char first = target[targetOffset];</span><br><span class="line">        int max = sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">        for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">            /* Look for first character. */</span><br><span class="line">            if (source[i] != first) &#123;</span><br><span class="line">                while (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* Found first character, now look at the rest of v2 */</span><br><span class="line">            if (i &lt;= max) &#123;</span><br><span class="line">                int j = i + 1;</span><br><span class="line">                int end = j + targetCount - 1;</span><br><span class="line">                for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                        == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">                if (j == end) &#123;</span><br><span class="line">                    /* Found whole string. */</span><br><span class="line">                    return i - sourceOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先判断开始索引如果大于源字符串则返回，若目标字符串长度为0返回源字符串长度，否则返回-1.</p><p>然后迭代查找字符，若全部源字符串都找到则返回第一个匹配的索引，否则返回-1.<br>所以在public boolean contains(CharSequence s)方法中，若indexOf方法返回-1则返回false，否则返回true。</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p>源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">        if (this == anObject) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (anObject instanceof String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123;</span><br><span class="line">                char v1[] = value;</span><br><span class="line">                char v2[] = anotherString.value;</span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123;</span><br><span class="line">                    if (v1[i] != v2[i])</span><br><span class="line">                        return false;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先判断this == anObject ？，也就是说判断要比较的对象和当前对象是不是同一个对象，如果是直接返回true，如不是再继续比较，然后在判断anObject是不是String类型的，如果不是，直接返回false,如果是再继续比较，到了能终于比较字符数组的时候，他还是先比较了两个数组的长度，不一样直接返回false，一样再逐一比较值。</p><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static String join(CharSequence delimiter, CharSequence... elements) &#123;</span><br><span class="line">        Objects.requireNonNull(delimiter);</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        // Number of elements not likely worth Arrays.stream overhead.</span><br><span class="line">        StringJoiner joiner = new StringJoiner(delimiter);</span><br><span class="line">        for (CharSequence cs: elements) &#123;</span><br><span class="line">            joiner.add(cs);</span><br><span class="line">        &#125;</span><br><span class="line">        return joiner.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><strong>StringJoiner 类也是jdk1.8开始加入的通过分隔符或前缀或后缀来构造字符串的，底层是字符序列的拷贝。</strong></p></li><li><p>requireNonNull方法校验参数不能为空,否则抛异常.源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">        if (obj == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h2><p> lastIndexOf(String str)与lastIndexOf(String str, int fromIndex) </p><blockquote><p>lastIndexOf(String str)方法返回字符串str在String中最后出现的起始的位置<br>lastIndexOf(String str, int fromIndex)方法返回在fromIndex位置之后字符串str在String中最后出现的起始的位置</p></blockquote><p>lastIndexOf(String str)源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int lastIndexOf(String str) &#123;</span><br><span class="line">        return lastIndexOf(str, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lastIndexOf(String str, int fromIndex)源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int lastIndexOf(String str, int fromIndex) &#123;</span><br><span class="line">        return lastIndexOf(value, 0, value.length,</span><br><span class="line">                str.value, 0, str.value.length, fromIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由上可见,lastIndexOf(String str)也是调用的lastIndexOf(String str, int fromIndex)方法,只不过fromIndex参数是String的长度</p><blockquote><p>看到这时会产生一个疑问,fromIndex是String的长度了,那怎么还能查到lastIndexOf的值呢? 带着这个疑问,继续往下看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static int lastIndexOf(char[] source, int sourceOffset, int sourceCount,</span><br><span class="line">            char[] target, int targetOffset, int targetCount,</span><br><span class="line">            int fromIndex) &#123;</span><br><span class="line">    </span><br><span class="line">        int rightIndex = sourceCount - targetCount;</span><br><span class="line">        if (fromIndex &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">            fromIndex = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Empty string always matches. */</span><br><span class="line">        if (targetCount == 0) &#123;</span><br><span class="line">            return fromIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int strLastIndex = targetOffset + targetCount - 1;</span><br><span class="line">        char strLastChar = target[strLastIndex];</span><br><span class="line">        int min = sourceOffset + targetCount - 1;</span><br><span class="line">        int i = min + fromIndex;</span><br><span class="line"></span><br><span class="line">    startSearchForLastChar:</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; min) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            int start = j - (targetCount - 1);</span><br><span class="line">            int k = strLastIndex - 1;</span><br><span class="line"></span><br><span class="line">            while (j &gt; start) &#123;</span><br><span class="line">                if (source[j--] != target[k--]) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                    continue startSearchForLastChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return start - sourceOffset + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们来逐步解析源码</p><ol><li></li></ol><ul><li>source : 被搜索的字符</li><li>sourceOffset :  源字符串的偏移量</li><li>sourceCount :  源字符串的计数</li><li>target : 要搜索的字符</li><li>targetOffset : 目标字符串的偏移量</li><li>targetCount : 目标字符串的计数</li><li>fromIndex: 从index开始搜索的索引</li></ul><ol start="2"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int rightIndex = sourceCount - targetCount;</span><br><span class="line"></span><br><span class="line"> if (fromIndex &gt; rightIndex) &#123;</span><br><span class="line">            fromIndex = rightIndex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>rightIndex为被搜索字符与目标字符的差,我们可以先假设目标字符在被搜索字符的最后位置,假如此时fromIndex是上面的疑问中的被搜索字符的长度,那么就将这个差值赋值给fromIndex.</p><blockquote><p>问:至于为什么要传入被搜索字符串的长度?<br>答:为了保证在fromIndex的值一定要大于等于rightIndex,从而使fromIndex = rightIndex</p></blockquote><ol start="3"><li>提前要说一下: 此方法是按照被搜索字符从右往左的顺序匹配目标字符的的</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int strLastIndex = targetOffset + targetCount - 1;</span><br><span class="line">char strLastChar = target[strLastIndex];</span><br><span class="line">int min = sourceOffset + targetCount - 1;</span><br><span class="line">int i = min + fromIndex;</span><br></pre></td></tr></table></figure></li></ol><ul><li>strLastIndex : 目标字符最大索引</li><li>strLastChar : 目标字符最大索引出所对应的值</li><li>min : 假设目标字符出现在最左边,min代表此时目标字符在被搜索字符的位置的索引</li><li>i : 被搜索字符的最大索引</li></ul><ol start="4"><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">startSearchForLastChar:</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; min) &#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            int start = j - (targetCount - 1);</span><br><span class="line">            int k = strLastIndex - 1;</span><br><span class="line"></span><br><span class="line">            while (j &gt; start) &#123;</span><br><span class="line">                if (source[j--] != target[k--]) &#123;</span><br><span class="line">                    i--;</span><br><span class="line">                    continue startSearchForLastChar;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return start - sourceOffset + 1;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p>中    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</span><br><span class="line">               i--;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>为了从右往左查找目标字符最后一位出现在被搜索字符的位置         </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int j = i - 1;</span><br><span class="line">int start = j - (targetCount - 1);</span><br><span class="line">int k = strLastIndex - 1;</span><br><span class="line"></span><br><span class="line">while (j &gt; start) &#123;</span><br><span class="line">    if (source[j--] != target[k--]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        continue startSearchForLastChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续从右往左第二位开始匹配,这里就不多说了.        </p><hr><p>参考文章: <a href="https://blog.csdn.net/u011726984/article/details/51326697" target="_blank" rel="noopener">https://blog.csdn.net/u011726984/article/details/51326697</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;环境: JDK8&lt;/p&gt;
&lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;p&gt;先看String类的定义&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>static关键字详解</title>
    <link href="http://www.litede.cn/2019/10/23/static%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.litede.cn/2019/10/23/static关键字详解/</id>
    <published>2019-10-23T06:51:18.000Z</published>
    <updated>2019-10-23T08:06:44.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static关键字的用途"><a href="#static关键字的用途" class="headerlink" title="static关键字的用途"></a>static关键字的用途</h1><blockquote><p>static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途    </p></blockquote><p> — 摘自&lt;&lt;java编程思想&gt;&gt;</p><p>这段话用一句话来描述就是: <strong>方便在没有创建对象的情况下来进行调用(方法/变量)</strong></p><p>很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。</p><p>　　static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。</p><ol><li>static修饰方法</li></ol><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。</p><p>但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。<br><img src="https://img-blog.csdnimg.cn/2019102315042990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>此时可以看到,静态方法print2不能访问非静态变量与非静态方法.而非静态方法print1可以不需要new直接访问print2方法.</p><p>由此可以看出,print2方法时独立于对象存在的,可以直接通过类名调用.例如: Class.print2();</p><ol start="2"><li>static修饰变量</li></ol><p>static变量也成为静态变量,静态变量和非静态变量的区别是:静态变量被所有的对象所共享,在内存中只有一个副本,它当且仅当在类初次加载时会被初始化.而非静态变量所拥有的,在创建对象的时候被初始化,存在多个副本,各个对象拥有的副本互不影响.</p><p>static成员变量的初始化顺序按照定义的顺序进行初始化.</p><ol start="3"><li>static修饰代码块<br>static关键字还有一个比较关键的作用就是<strong>用来形成静态代码块以优化程序性能</strong>. static块可以置于类中的任何地方,类中可以有多个static块.在类初次加载时,会按照static块ed顺序来执行每个static块,并且只执行一次.</li></ol><p>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private Date birthDate;</span><br><span class="line">     </span><br><span class="line">    public Person(Date birthDate) &#123;</span><br><span class="line">        this.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    boolean isBornBoomer() &#123;</span><br><span class="line">        Date startDate = Date.valueOf(&quot;1946&quot;);</span><br><span class="line">        Date endDate = Date.valueOf(&quot;1964&quot;);</span><br><span class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private Date birthDate;</span><br><span class="line">    private static Date startDate,endDate;</span><br><span class="line">    static&#123;</span><br><span class="line">        startDate = Date.valueOf(&quot;1946&quot;);</span><br><span class="line">        endDate = Date.valueOf(&quot;1964&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Person(Date birthDate) &#123;</span><br><span class="line">        this.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    boolean isBornBoomer() &#123;</span><br><span class="line">        return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</p><h1 id="static关键字误区"><a href="#static关键字误区" class="headerlink" title="static关键字误区"></a>static关键字误区</h1><ol><li>static关键字会改变类中成员的访问权限吗？</li></ol><p>ava中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。</p><ol start="2"><li>能通过this访问静态成员变量吗？</li></ol><p>这里面主要考察队this和static的理解。this代表什么？this代表当前对象。而static变量是被对象所享有的，静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。</p><ol start="3"><li>static能作用于局部变量么？</li></ol><p>static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。</p><h1 id="常见的面试题"><a href="#常见的面试题" class="headerlink" title="常见的面试题"></a>常见的面试题</h1><ol><li>下面这段代码的输出结果是什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test extends Base&#123;</span><br><span class="line"> </span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;test static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Test()&#123;</span><br><span class="line">        System.out.println(&quot;test constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Base&#123;</span><br><span class="line">     </span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;base static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Base()&#123;</span><br><span class="line">        System.out.println(&quot;base constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">base static</span><br><span class="line">test static</span><br><span class="line">base constructor</span><br><span class="line">test constructor</span><br></pre></td></tr></table></figure><p>解析: </p><ol><li><p>从main方法开始执行,先加载Test类</p></li><li><p>Test类继承Base类,因此先去加载Base类,发现有static代码块,便开始执行static代码块.此时输出: <strong>base static</strong></p></li><li><p>base类加载完成后,继续加载Test类,发现Test类中也有static方法,便开始执行static代码块,此时输出: <strong>test static</strong></p></li><li><p>在加载完静态代码后,便继续执行main方法,在main方法中new Test()时会先调用父类的构造器,输出: <strong>base constructor</strong></p></li><li><p>再调用自身的构造器,输出<strong>test constructor</strong></p></li><li><p>这段代码的输出结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    Person person = new Person(&quot;Test&quot;);</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;test static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Test() &#123;</span><br><span class="line">        System.out.println(&quot;test constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Person&#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;person static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String str) &#123;</span><br><span class="line">        System.out.println(&quot;person &quot;+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class MyClass extends Test &#123;</span><br><span class="line">    Person person = new Person(&quot;MyClass&quot;);</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;myclass static&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public MyClass() &#123;</span><br><span class="line">        System.out.println(&quot;myclass constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test static</span><br><span class="line">myclass static</span><br><span class="line">person static</span><br><span class="line">person Test</span><br><span class="line">test constructor</span><br><span class="line">person MyClass</span><br><span class="line">myclass constructor</span><br></pre></td></tr></table></figure><blockquote><ol><li>先加载Test类,执行其中的static方法,输出:<strong>test static</strong></li><li>再加载MyClass类中的static方法,输出:<strong>myclass static</strong></li><li>在加载完static后,就通过构造器来生成对象.而在生成对象的时候,必须先初始化父类的成员变量,因此会执行Test中的<strong>Person person = new Person()</strong>,而Person类还没有被加载过,因此会先加载Person类中的static块,输出<strong>person static</strong></li><li>继续执行Person的构造器,输出:<strong>person Test</strong></li><li>继续执行Test类中的构造器,输出:<strong>test constructor</strong>.此时完成了父类的初始化</li><li>初始化自身,因此会继续执行MyClass中的Person person = new Person()，输出:<strong>person MyClass</strong></li><li>执行myClass中的构造器,输出:<strong>myclass constructor</strong></li></ol></blockquote><ol start="3"><li>这段代码的输出结果是什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">     </span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;test static 1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;test static 2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test static 1</span><br><span class="line">test static 2</span><br></pre></td></tr></table></figure><p>初始化时加载静态代码块,其余不解释</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;static关键字的用途&quot;&gt;&lt;a href=&quot;#static关键字的用途&quot; class=&quot;headerlink&quot; title=&quot;static关键字的用途&quot;&gt;&lt;/a&gt;static关键字的用途&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;static方法就是没有this的
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java里的构造函数</title>
    <link href="http://www.litede.cn/2019/10/23/java%E9%87%8C%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <id>http://www.litede.cn/2019/10/23/java里的构造函数/</id>
    <published>2019-10-23T06:26:38.000Z</published>
    <updated>2019-10-23T08:06:44.187Z</updated>
    
    <content type="html"><![CDATA[<p>Java里的构造函数(构造方法)</p><p>构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们,即构造函数的重载。</p><ol><li>构造函数的特点</li></ol><p>① 构造函数的主要作用是完成对象的初始化工作,如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数,它能够把定义对象时的参数传给对象的域.意即当创建一个对象时,这个对象就被初始化,如果这是构造函数不为空,则在创建对象时就执行构造函数里面的代码.</p><p>② 构造函数的名称必须与类名相同,不包括大小写;</p><p>③ 构造函数没有返回值,也不能用void修饰,如果加上了返回值类型,那么这将使这个构造函数变成一个普<br>通的方法,在运行时将产生找不到构造方法的错误.</p><p>④ 一个类可以定义多个构造犯法,如果在定义类时没有定义构造方法,则编译系统会自动插入一个无参数的默认构造函数,这个构造器不执行任何代码</p><p>⑤ 构造方法可以重载,以参数的个数,类型,顺序区分.<br>⑥ 在函数的继承里,子类必须调用父类的构造函数.但是,子类只能继承父类的默认构造函数,如果父类没有默认构造函数,那子类不能从父类继承默认构造函数,这时子类必须使用super来实现对父类的为默认构造函数的调用.在创建对象时,先调用父类默认构造函数对对象进行初始化,然后调用子类自身定义的构造函数.</p><ol start="2"><li>针对1中的⑥进行代码展示</li></ol><p>父类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Class &#123;</span><br><span class="line">    int age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Class(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类中使用有参的构造方法,此时不会生成默认的无参构造方法.</p><p>子类:</p><p>我们先让子类继承父类,会产生如下报错</p><p><img src="https://img-blog.csdnimg.cn/20191023144537656.png" alt="List item"></p><p>可以看到,java让Student类中实现父类的构造方法,代码完成后是这样的:<br><img src="https://img-blog.csdnimg.cn/2019102314472796.png" alt="在这里插入图片描述"></p><p>这就是刚才说的,子类必须使用super来实现对父类的非默认构造方法的调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java里的构造函数(构造方法)&lt;/p&gt;
&lt;p&gt;构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们,即构造函
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.litede.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.litede.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>vps搭建shadowsocks</title>
    <link href="http://www.litede.cn/2019/10/23/vps%E6%90%AD%E5%BB%BAshadowsocks/"/>
    <id>http://www.litede.cn/2019/10/23/vps搭建shadowsocks/</id>
    <published>2019-10-23T02:24:28.000Z</published>
    <updated>2019-10-23T03:16:12.194Z</updated>
    
    <content type="html"><![CDATA[<p><strong>出于程序员的本能，我尝试在外网上搭建了一个VPN（搭建成功后就删除了，证明自己搭建成功过就满足了），现在记录一下步骤</strong></p><p>一、 购买服务器 </p><pre><code>经过筛选，我选择了vultr服务器，每月5美元，建议地址选Tokyo，操作系统选centos7，最好不要选8，配置选最小即可，然后部署服务器</code></pre><p>二、 部署shadowsocks</p><pre><code>这里使用的是秋水逸冰的Python版一键安装脚本，使用方法如下：1. 使用root用户，运行如下命令</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure><p>其中需要输入一些信息如IP、Port、password等，均可自己定义</p><p>安装完成后，脚本提示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Congratulations, Shadowsocks-python server install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/342.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><p>单用户配置文件示例：<br>配置文件路径：/etc/shadowsocks.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:your_server_port,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;your_password&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;your_encryption_method&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多用户多端口配置文件示例：<br>配置文件路径：/etc/shadowsocks.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;port_password&quot;:&#123;</span><br><span class="line">         &quot;8989&quot;:&quot;password0&quot;,</span><br><span class="line">         &quot;9001&quot;:&quot;password1&quot;,</span><br><span class="line">         &quot;9002&quot;:&quot;password2&quot;,</span><br><span class="line">         &quot;9003&quot;:&quot;password3&quot;,</span><br><span class="line">         &quot;9004&quot;:&quot;password4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;your_encryption_method&quot;,</span><br><span class="line">    &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令：<br>启动：/etc/init.d/shadowsocks start</p><p>停止：/etc/init.d/shadowsocks stop</p><p>重启：/etc/init.d/shadowsocks restart</p><p>状态：/etc/init.d/shadowsocks status</p><p>以上引用自 &gt; <a href="http://www.wangchao.info/1148.html" target="_blank" rel="noopener">http://www.wangchao.info/1148.html</a> 有改动</p><p>三、 KCPTun加速</p><p>搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。</p><p>KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。</p><p>KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。</p><ol><li>首先需要确认一下加速地址，大部分不能加速是因为加速地址配置错误</li></ol><p>首先找到Shadowsocks端口，如8388，然后再命令行输入一下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nl | grep 8388</span><br></pre></td></tr></table></figure><p>如果提示以上命令不存在，则输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -nl | grep 8388</span><br></pre></td></tr></table></figure><p>然后你会看到类似下面的输出（着重看显示为红色的部分）：</p><p>情况一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0     :::8388                 :::*                    LISTEN     </span><br><span class="line">udp6       0      0     :::8388                 :::*</span><br></pre></td></tr></table></figure><p>情况二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     127.0.0.1:8388                 :::*              LISTEN     </span><br><span class="line">udp       0      0     127.0.0.1:8388                 :::*</span><br></pre></td></tr></table></figure><p>情况三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     0.0.0.0:8388                 :::*                    LISTEN     </span><br><span class="line">udp       0      0     0.0.0.0:8388                 :::*</span><br></pre></td></tr></table></figure><p>情况四：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp       0      0     10.10.10.10:8388                 :::*                 LISTEN     </span><br><span class="line">udp       0      0     10.10.10.10:8388                 :::*</span><br></pre></td></tr></table></figure><p>情况五：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">udp    UNCONN     0      0         *:1080                  *:*                  </span><br><span class="line">tcp    LISTEN     0      128       *:1080                  *:*</span><br></pre></td></tr></table></figure><p>若为情况1、情况2、情况5和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口）</p><p>若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口）</p><ol start="2"><li>Kcptun 一键安装脚本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O kcptun.sh https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh</span><br><span class="line">sh kcptun.sh</span><br></pre></td></tr></table></figure><p>同样也需要一些自定义配置,其中的加速IP按上面说的填写。</p><blockquote><p>注： 填写完成后会提示按任意键继续和CTRL+C退出，此时要按任意键</p><p>如果安装成功，应该能看到如下信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt; 恭喜, Kcptun 服务端配置完毕！</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 正在获取当前安装的 Kcptun 版本...</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 服务器IP:  10.10.10.10</span><br><span class="line">&gt; 端口:  29900</span><br><span class="line">&gt; 加速地址: 127.0.0.1:8388</span><br><span class="line">&gt; 密码: 123456</span><br><span class="line">&gt; 加密方式 Crypt:  salsa20</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 当前安装的 Kcptun 版本为: v20160922</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 推荐的客户端配置为: </span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;   &quot;localaddr&quot;: &quot;:8388&quot;,</span><br><span class="line">&gt;   &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,</span><br><span class="line">&gt;   &quot;key&quot;: &quot;123456&quot;,</span><br><span class="line">&gt;   &quot;crypt&quot;: &quot;salsa20&quot;,</span><br><span class="line">&gt;   &quot;mode&quot;: &quot;fast&quot;,</span><br><span class="line">&gt;   &quot;mtu&quot;: 1350,</span><br><span class="line">&gt;   &quot;sndwnd&quot;: 1024,</span><br><span class="line">&gt;   &quot;rcvwnd&quot;: 1024,</span><br><span class="line">&gt;   &quot;datashard&quot;: 10,</span><br><span class="line">&gt;   &quot;parityshard&quot;: 3,</span><br><span class="line">&gt;   &quot;dscp&quot;: 0,</span><br><span class="line">&gt;   &quot;conn&quot;: 1,</span><br><span class="line">&gt;   &quot;autoexpire&quot;: 60,</span><br><span class="line">&gt;   &quot;nocomp&quot;: false</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 手机端参数可以使用：</span><br><span class="line">&gt;   *******</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 其他参数请自行计算或设置, 详细信息可以查看: https://github.com/xtaci/kcptun</span><br><span class="line">&gt;  </span><br><span class="line">&gt; Kcptun 安装目录: /usr/share/kcptun</span><br><span class="line">&gt; Kcptun 日志文件目录: /var/log/kcptun/</span><br></pre></td></tr></table></figure><p>请将以上的提示信息复制保存下来，后面配置客户端会用到这些提示信息。<br>注意：服务端的 sndwnd 对应的是客户端的 recwnd，所以请不要问我为什么输出的客户端参数和你配置的服务端参数是反的。</p><p>安装之后，Kcptun 服务交由 Supervisor 管理。</p><p>Supervisor 相关命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service supervisord &#123;start|stop|restart|status&#125;</span><br></pre></td></tr></table></figure><p>Kcptun 相关命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl &#123;start|stop|restart|status&#125; kcptun</span><br></pre></td></tr></table></figure><p>Supervisor 启动的时候会同时启动 Kcptun，运行 kcptun 相关命令时先确保 Supervisor 已启动。</p><p>四、客户端配置（windows，没有mac）</p><ol><li>先下载一个Kcptun工具.按照kcptun执行完成以后保存的信息填入Kcptun中相关的位置</li><li>下载Shadowsocks，填写相关信息，注意：其中的密码和加密方式一定要与服务器shadowsocks配置的相同，否则不能联网。</li></ol><p>到此位止，我的VPN就搭建好了，试一下可以访问谷歌而且很稳定。</p><p>在vultr上是按照时间付钱的，可以在不用的时候删掉服务器，不再扣钱。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;出于程序员的本能，我尝试在外网上搭建了一个VPN（搭建成功后就删除了，证明自己搭建成功过就满足了），现在记录一下步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、 购买服务器 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;经过筛选，我选择了vultr服务器，每月5美元，建议地址选
      
    
    </summary>
    
    
      <category term="vps搭建shadowsocks" scheme="http://www.litede.cn/categories/vps%E6%90%AD%E5%BB%BAshadowsocks/"/>
    
    
      <category term="vps搭建shadowsocks" scheme="http://www.litede.cn/tags/vps%E6%90%AD%E5%BB%BAshadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>搭建dubbo服务</title>
    <link href="http://www.litede.cn/2019/10/06/%E6%90%AD%E5%BB%BAdubbo%E6%9C%8D%E5%8A%A1/"/>
    <id>http://www.litede.cn/2019/10/06/搭建dubbo服务/</id>
    <published>2019-10-06T01:46:47.000Z</published>
    <updated>2019-10-06T02:09:33.385Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo目录结构如图所示：<br><img src="https://img-blog.csdnimg.cn/20191006094911275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>生产者为服务的被调用方<br>生产者为服务的调用方</strong><br><strong>API为生产者和消费者中间的桥梁</strong>，这个是必不可少的。原因：</p><ol><li>如果没有API的话，消费者需要将生产者的包导入到本地仓库，这样就相当于把生产者的代码放到了本地，不符合微服务的理念</li><li>假如没有API的话，消费者需要将生产者的包导入到本地仓库，如果此时生产者的代码发生了变化，消费者必须每次手动清楚生产者的包进行重新导包，这样的设计是非常垃圾的。</li><li>假如有API的话，我们通过API远程调用生产者的接口，这样不管生产者的代码怎么变化，我们都是通过API调用的最新的代码。这种设计是才是合理的。<br>一、POM。xml</li><li>根 pom.xml</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;consumers&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;api&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;providers&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;revision&gt;2.7.1&lt;/revision&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>providers pom.xml</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;providers&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;revision&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>consumers pom.xml</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;consumers&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;revision&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>api pom.xml</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>二、 resources</p><ol><li>providers application.yml</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: providers</span><br><span class="line">dubbo:</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: com.fengqi.providers.service</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: <span class="number">9010</span></span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper:<span class="comment">//39.105.132.36:$&#123;embedded.zookeeper.port&#125;</span></span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8282</span></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: <span class="number">1.0</span>.0</span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: <span class="number">2181</span></span><br></pre></td></tr></table></figure><ol start="2"><li>consumers application.yml</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumers</span><br><span class="line"></span><br><span class="line">demo:</span><br><span class="line">  service:</span><br><span class="line">    version: <span class="number">1.0</span>.0</span><br><span class="line"></span><br><span class="line">embedded:</span><br><span class="line">  zookeeper:</span><br><span class="line">    port: <span class="number">2181</span></span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper:<span class="comment">//39.105.132.36:$&#123;embedded.zookeeper.port&#125;</span></span><br><span class="line">    file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cache</span><br><span class="line">server:</span><br><span class="line">  port: <span class="number">8281</span></span><br></pre></td></tr></table></figure><p>注： api不需要yml</p><p>三.、代码</p><ol><li>providers</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> com.fengqi.providers.service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fengqi.api.ApiService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiServiceImpl</span> <span class="keyword">implements</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;dubbo.application.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"[%s] : Hello, %s"</span>, serviceName, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>consumers</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fengqi.consumers.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fengqi.api.ApiService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumersController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line">    <span class="keyword">private</span> ApiService apiService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apiService.sayHello(<span class="string">"李特"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>api</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fengqi.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，一个多module的dubbo服务就已经完成了 ，运行看一下吧。</p><p>项目地址： <a href="https://github.com/litete/dubbo-zookeeper-demo.git" target="_blank" rel="noopener">https://github.com/litete/dubbo-zookeeper-demo.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dubbo目录结构如图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191006094911275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shad
      
    
    </summary>
    
    
      <category term="dubbo" scheme="http://www.litede.cn/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://www.litede.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Idea远程一键部署springboot到Docker</title>
    <link href="http://www.litede.cn/2019/10/06/Idea%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2springboot%E5%88%B0Docker/"/>
    <id>http://www.litede.cn/2019/10/06/Idea远程一键部署springboot到Docker/</id>
    <published>2019-10-06T01:09:39.000Z</published>
    <updated>2019-10-06T01:33:43.626Z</updated>
    
    <content type="html"><![CDATA[<p>**</p><h2 id="Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？"><a href="#Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？" class="headerlink" title="Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？"></a>Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？</h2><p>**</p><h2 id="一、-开发前准备"><a href="#一、-开发前准备" class="headerlink" title="一、 开发前准备"></a>一、 开发前准备</h2><ol><li><p>Docker的安装可以参考<a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p></li><li><p>配置docker远程连接端口</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure><p>找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375，如下图所示<br><img src="https://img-blog.csdnimg.cn/20191006091149961.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li>重启docker</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="4"><li>开放端口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=<span class="keyword">public</span> --add-port=<span class="number">2375</span>/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="5"><li>Idea安装<strong>docker</strong>插件,重启<br><img src="https://img-blog.csdnimg.cn/20191006091416311.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>连接远程docker<br>(1) 编辑配置<br><img src="https://img-blog.csdnimg.cn/2019100609145883.jpg" alt="在这里插入图片描述"><br>(2) 填远程docker地址<br><img src="https://img-blog.csdnimg.cn/20191006091526731.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(3) 连接成功，会列出远程docker容器和镜像<br><img src="https://img-blog.csdnimg.cn/20191006091552984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h2 id="二、新建项目"><a href="#二、新建项目" class="headerlink" title="二、新建项目"></a>二、新建项目</h2><ol><li>创建springboot项目</li></ol><p>项目结构图<br><img src="https://img-blog.csdnimg.cn/20191006091643540.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(1) 配置pom文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dockerDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.fengqi&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;web&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;</span><br><span class="line">                    &lt;resources&gt;</span><br><span class="line">                        &lt;resource&gt;</span><br><span class="line">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                            &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt;</span><br><span class="line">                            &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt;</span><br><span class="line">                        &lt;/resource&gt;</span><br><span class="line">                    &lt;/resources&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;tasks&gt;</span><br><span class="line">                                &lt;copy todir="src/main/docker" file="target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;"&gt;&lt;/copy&gt;</span><br><span class="line">                            &lt;/tasks&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;run&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>(2) 在src/main目录下创建docker目录，并创建Dockerfile文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line">ADD *.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span><br></pre></td></tr></table></figure><p>(3) 在resource目录下创建application.properties文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging.config=classpath:logback.xml</span><br><span class="line">logging.path=/home/developer/app/logs/</span><br><span class="line">server.port=<span class="number">8990</span></span><br></pre></td></tr></table></figure><p>(4) 创建DockerApplication文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerApplication</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> SpringApplication.run(DockerApplication.class, args);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) 创建DockerController文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DockerController</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> Log log = LogFactory.getLog(DockerController.class);</span><br><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> log.info(<span class="string">"Hello Docker!"</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Hello Docker!"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(6) 增加配置<br><img src="https://img-blog.csdnimg.cn/20191006091954238.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191006092002910.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>命令解释<br>Image tag : 指定镜像名称和tag，镜像名称为 docker-demo，tag为1.1<br>Bind ports : 绑定宿主机端口到容器内部端口。格式为[宿主机端口]:[容器内部端口]<br>Bind mounts : 将宿主机目录挂到到容器内部目录中。格式为[宿主机目录]:[容器内部目录]。这个springboot项目会将日志打印在容器 /home/developer/app/logs/ 目录下，将宿主机目录挂载到容器内部目录后，那么日志就会持久化容器外部的宿主机目录中。</strong></p><p>(7) Maven打包<br><img src="https://img-blog.csdnimg.cn/20191006092051828.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(8) 运行<br><img src="https://img-blog.csdnimg.cn/20191006092345561.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191006092407773.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里我们可以看到镜像名称为docker-demo:1.1，docker容器为docker-server</p><blockquote><p>参考<a href="https://www.toutiao.com/i6702260511217549832/" target="_blank" rel="noopener">https://www.toutiao.com/i6702260511217549832/</a> 文章，有改动</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&quot;Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？&quot;&gt;&lt;a href=&quot;#Idea是Java开发利器，springboot是Java生态
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.litede.cn/categories/docker/"/>
    
    
      <category term="docker" scheme="http://www.litede.cn/tags/docker/"/>
    
      <category term="SpringBoot" scheme="http://www.litede.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot读取外部配置文件</title>
    <link href="http://www.litede.cn/2019/10/05/SpringBoot%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://www.litede.cn/2019/10/05/SpringBoot读取外部配置文件/</id>
    <published>2019-10-05T08:26:07.000Z</published>
    <updated>2019-10-05T08:52:00.039Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候项目打包成一个jar 或者war ,通过java -jar 命令运行springboot 项目，因为springboot<br>项目有自己的application.properties<br>配置文件，但是我们打完包之后，它也会打到包里边，倒是也能打开压缩包修改properties 文件，但是也是较为麻烦。</p><p>现在有如下需求，比如客户需要在很多个服务器部署一套项目，但是它们的数据库连接不一样，我们不能针对于这么多服务器，多次打包，很恶心，当然可以打完包，复制一堆，分别修改压缩包里边的配置文件。</p><p>springboot 有读取外部配置文件的方法，如下优先级：</p><p>第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。</p><p>第二种是直接把配置文件放到jar包的同级目录。</p><p>第三种在classpath下建一个config文件夹，然后把配置文件放进去。</p><p>第四种是在classpath下直接放配置文件。</p><p>看到如上的优先级了吗？也就是说springboot<br>默认是优先读取它本身同级目录下的一个config/application.properties<br>文件的。我们通常在src/main/resources 文件夹下创建的application.properties<br>文件的优先级竟然是最低的！！！。</p></blockquote><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><ol><li>新建Project（本人使用的是IDEA），很简单，此处不再赘述。</li><li>在项目根目录下新建config文件夹</li><li>在config文件夹下新建application.properties或application.yml文件<br>如图所示：<br><img src="https://img-blog.csdnimg.cn/20191005163459624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGVkZQ==,size_16,color_FFFFFF,t_70" alt="如图所示"></li></ol><hr><p> 此处的优先级大于src目录下的application.yml文件. 我们可以把一些公共的配置文件代码放置到此处，这样就达到配置文件代码解耦合的目的了</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候项目打包成一个jar 或者war ,通过java -jar 命令运行springboot 项目，因为springboot&lt;br&gt;项目有自己的application.properties&lt;br&gt;配置文件，但是我们打完包之后，它也会打到包里边，倒
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://www.litede.cn/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://www.litede.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo和Gitpage搭建博客(二)</title>
    <link href="http://www.litede.cn/2019/09/20/Hexo%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98/"/>
    <id>http://www.litede.cn/2019/09/20/Hexo使用Next主题/</id>
    <published>2019-09-20T09:30:57.000Z</published>
    <updated>2019-09-20T10:05:21.061Z</updated>
    
    <content type="html"><![CDATA[<p>在进行了<strong><a href="http://www.litede.cn/2019/09/20/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">Hexo和GitPage搭建博客</a>之后需要将本地博客推送到GitPage上，具体操作下面在文章内介绍。</strong></p><h2 id="一、注册Github"><a href="#一、注册Github" class="headerlink" title="一、注册Github"></a>一、注册Github</h2><p>&emsp;&emsp;首先如果你还没有 Github 账号的先注册一个，此处不赘述</p><hr><h2 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h2><p>点击 Start project 或者下面的 new repository 创建一个新的仓库</p><p><img src="/images/%E5%88%9B%E5%BB%BAgithub%E4%BB%93%E5%BA%93.png" alt><br>注：由于我已经有相同的仓库名了 所以此处会报错，请忽略此错误</p><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>注：myBlog为文件夹的名字 可根据自己的需求修改</p><h2 id="三、配置SSH-Key"><a href="#三、配置SSH-Key" class="headerlink" title="三、配置SSH Key"></a>三、配置SSH Key</h2><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。<br>如有需要请自行Google，此处不再赘述</p><h2 id="四、部署到Github"><a href="#四、部署到Github" class="headerlink" title="四、部署到Github"></a>四、部署到Github</h2><p>此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。</p><ul><li>第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）<br><img src="/images/github%E5%90%8D%E7%A7%B0.jpg" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:@@@/@@@.github.io.git</span><br></pre></td></tr></table></figure></li></ul><p>注： @@@/@@@ 需要修改为自己的链接</p><ul><li>第二：要安装一个部署插件 hexo-deployer-git。</li></ul><p><code>npm install hexo-deployer-git --save</code></p><p>最后执行以下命令就可以部署上传啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>命令提示：</p><p><code>hexo g</code> 生成环境<br><code>hexo d</code> 部署环境<br><code>hexo s</code> 启动服务预览</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行了&lt;strong&gt;&lt;a href=&quot;http://www.litede.cn/2019/09/20/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/&quot;&gt;Hexo和Gi
      
    
    </summary>
    
    
      <category term="Hexo+GitPage" scheme="http://www.litede.cn/categories/Hexo-GitPage/"/>
    
    
      <category term="Hexo+GitPage" scheme="http://www.litede.cn/tags/Hexo-GitPage/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo和Gitpage搭建博客(一)</title>
    <link href="http://www.litede.cn/2019/09/20/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.litede.cn/2019/09/20/使用Hexo和Gitpage搭建博客/</id>
    <published>2019-09-20T08:29:50.000Z</published>
    <updated>2019-09-20T10:05:17.799Z</updated>
    
    <content type="html"><![CDATA[<p><strong>作为一个程序员，个人博客可以说是不可或缺的。它可以记录自己技术成长的过程，也可以供别人参考、给他人提供方便，还可以锻炼自己的表达能力等等。这几年陆陆续续的在很多地方写过博客（CSDN、个人服务器），但是都有一些缺陷，所以最后决定用GitPage作为自己博客的新起点</strong></p><blockquote><p>Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p></blockquote><h2 id="一、准备环境"><a href="#一、准备环境" class="headerlink" title="一、准备环境"></a>一、准备环境</h2><p>&emsp;&emsp;1.node.js<br>&emsp;&emsp;2.git<br><strong>安装非常简单 此处不再赘述</strong><br>&emsp;&emsp;安装验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><hr><h2 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h2><p>在命令行输入执行以下命令：</p><p><code>npm install -g hexo-cli</code></p><p>安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init myBlog</span><br><span class="line">cd myBlog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>注：myBlog为文件夹的名字 可根据自己的需求修改</p><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 </span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds # 模版文件夹</span><br><span class="line">├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹</span><br><span class="line">|   ├── _drafts # 草稿文件</span><br><span class="line">|   └── _posts # 文章Markdowm文件 </span><br><span class="line">└── themes  # 主题文件夹</span><br></pre></td></tr></table></figure><p>好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 回车就可以预览效果了。<br><code>hexo s</code></p><p>以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。<br><img src="/images/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%88%AA%E5%9B%BE.png" alt="个人博客截图" title="个人博客截图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;作为一个程序员，个人博客可以说是不可或缺的。它可以记录自己技术成长的过程，也可以供别人参考、给他人提供方便，还可以锻炼自己的表达能力等等。这几年陆陆续续的在很多地方写过博客（CSDN、个人服务器），但是都有一些缺陷，所以最后决定用GitPage作为自己博客的
      
    
    </summary>
    
    
      <category term="Hexo+GitPage" scheme="http://www.litede.cn/categories/Hexo-GitPage/"/>
    
    
      <category term="Hexo+GitPage" scheme="http://www.litede.cn/tags/Hexo-GitPage/"/>
    
  </entry>
  
</feed>
