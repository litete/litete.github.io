<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vps搭建shadowsocks]]></title>
    <url>%2F2019%2F10%2F23%2Fvps%E6%90%AD%E5%BB%BAshadowsocks%2F</url>
    <content type="text"><![CDATA[出于程序员的本能，我尝试在外网上搭建了一个VPN（搭建成功后就删除了，证明自己搭建成功过就满足了），现在记录一下步骤一、 购买服务器 经过筛选，我选择了vultr服务器，每月5美元，建议地址选Tokyo，操作系统选centos7，最好不要选8，配置选最小即可，然后部署服务器二、 部署shadowsocks 这里使用的是秋水逸冰的Python版一键安装脚本，使用方法如下： 1. 使用root用户，运行如下命令123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 其中需要输入一些信息如IP、Port、password等，均可自己定义 安装完成后，脚本提示如下： 12345678 Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 单用户配置文件示例：配置文件路径：/etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例：配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 以上引用自 &gt; http://www.wangchao.info/1148.html 有改动 三、 KCPTun加速 搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。 KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。 KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 首先需要确认一下加速地址，大部分不能加速是因为加速地址配置错误 首先找到Shadowsocks端口，如8388，然后再命令行输入一下命令： 1netstat -nl | grep 8388 如果提示以上命令不存在，则输入 1ss -nl | grep 8388 然后你会看到类似下面的输出（着重看显示为红色的部分）： 情况一： 12tcp6 0 0 :::8388 :::* LISTEN udp6 0 0 :::8388 :::* 情况二： 12tcp 0 0 127.0.0.1:8388 :::* LISTEN udp 0 0 127.0.0.1:8388 :::* 情况三： 12tcp 0 0 0.0.0.0:8388 :::* LISTEN udp 0 0 0.0.0.0:8388 :::* 情况四： 12tcp 0 0 10.10.10.10:8388 :::* LISTEN udp 0 0 10.10.10.10:8388 :::* 情况五： 12udp UNCONN 0 0 *:1080 *:* tcp LISTEN 0 128 *:1080 *:* 若为情况1、情况2、情况5和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口） 若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口） Kcptun 一键安装脚本 12wget --no-check-certificate -O kcptun.sh https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.shsh kcptun.sh 同样也需要一些自定义配置,其中的加速IP按上面说的填写。 注： 填写完成后会提示按任意键继续和CTRL+C退出，此时要按任意键 如果安装成功，应该能看到如下信息 12345678910111213141516171819202122232425262728293031323334353637&gt; 恭喜, Kcptun 服务端配置完毕！&gt; &gt; 正在获取当前安装的 Kcptun 版本...&gt; &gt; 服务器IP: 10.10.10.10&gt; 端口: 29900&gt; 加速地址: 127.0.0.1:8388&gt; 密码: 123456&gt; 加密方式 Crypt: salsa20&gt; &gt; 当前安装的 Kcptun 版本为: v20160922&gt; &gt; 推荐的客户端配置为: &gt; &#123;&gt; &quot;localaddr&quot;: &quot;:8388&quot;,&gt; &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,&gt; &quot;key&quot;: &quot;123456&quot;,&gt; &quot;crypt&quot;: &quot;salsa20&quot;,&gt; &quot;mode&quot;: &quot;fast&quot;,&gt; &quot;mtu&quot;: 1350,&gt; &quot;sndwnd&quot;: 1024,&gt; &quot;rcvwnd&quot;: 1024,&gt; &quot;datashard&quot;: 10,&gt; &quot;parityshard&quot;: 3,&gt; &quot;dscp&quot;: 0,&gt; &quot;conn&quot;: 1,&gt; &quot;autoexpire&quot;: 60,&gt; &quot;nocomp&quot;: false&gt; &#125;&gt; &gt; 手机端参数可以使用：&gt; *******&gt; &gt; 其他参数请自行计算或设置, 详细信息可以查看: https://github.com/xtaci/kcptun&gt; &gt; Kcptun 安装目录: /usr/share/kcptun&gt; Kcptun 日志文件目录: /var/log/kcptun/ 请将以上的提示信息复制保存下来，后面配置客户端会用到这些提示信息。注意：服务端的 sndwnd 对应的是客户端的 recwnd，所以请不要问我为什么输出的客户端参数和你配置的服务端参数是反的。 安装之后，Kcptun 服务交由 Supervisor 管理。 Supervisor 相关命令： 1service supervisord &#123;start|stop|restart|status&#125; Kcptun 相关命令： 1supervisorctl &#123;start|stop|restart|status&#125; kcptun Supervisor 启动的时候会同时启动 Kcptun，运行 kcptun 相关命令时先确保 Supervisor 已启动。 四、客户端配置（windows，没有mac） 先下载一个Kcptun工具.按照kcptun执行完成以后保存的信息填入Kcptun中相关的位置 下载Shadowsocks，填写相关信息，注意：其中的密码和加密方式一定要与服务器shadowsocks配置的相同，否则不能联网。 到此位止，我的VPN就搭建好了，试一下可以访问谷歌而且很稳定。 在vultr上是按照时间付钱的，可以在不用的时候删掉服务器，不再扣钱。]]></content>
      <tags>
        <tag>vps搭建shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建dubbo服务]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%90%AD%E5%BB%BAdubbo%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[dubbo目录结构如图所示：生产者为服务的被调用方生产者为服务的调用方API为生产者和消费者中间的桥梁，这个是必不可少的。原因： 如果没有API的话，消费者需要将生产者的包导入到本地仓库，这样就相当于把生产者的代码放到了本地，不符合微服务的理念 假如没有API的话，消费者需要将生产者的包导入到本地仓库，如果此时生产者的代码发生了变化，消费者必须每次手动清楚生产者的包进行重新导包，这样的设计是非常垃圾的。 假如有API的话，我们通过API远程调用生产者的接口，这样不管生产者的代码怎么变化，我们都是通过API调用的最新的代码。这种设计是才是合理的。一、POM。xml 根 pom.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;consumers&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;module&gt;providers&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;revision&gt;2.7.1&lt;/revision&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; providers pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;providers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; consumers pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;consumers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; api pom.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 二、 resources providers application.yml 1234567891011121314151617181920spring: application: name: providersdubbo: scan: base-packages: com.fengqi.providers.service protocol: name: dubbo port: 9010 registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8282demo: service: version: 1.0.0embedded: zookeeper: port: 2181 consumers application.yml 123456789101112131415161718spring: application: name: consumersdemo: service: version: 1.0.0embedded: zookeeper: port: 2181dubbo: registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8281 注： api不需要yml 三.、代码 providers 123456789101112131415161718 package com.fengqi.providers.service;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Service;import org.springframework.beans.factory.annotation.Value;@Service(version = "1.0.0")public class ApiServiceImpl implements ApiService &#123; @Value("$&#123;dubbo.application.name&#125;") private String serviceName; @Override public String sayHello(String name) &#123; return String.format("[%s] : Hello, %s", serviceName, name); &#125;&#125; consumers 1234567891011121314151617181920package com.fengqi.consumers.controller;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class ConsumersController &#123; @Reference(version = "1.0.0") private ApiService apiService; @GetMapping public String getProviders() &#123; return apiService.sayHello("李特"); &#125;&#125; api 12345package com.fengqi.api;public interface ApiService &#123; String sayHello(String name);&#125; 此时，一个多module的dubbo服务就已经完成了 ，运行看一下吧。 项目地址： https://github.com/litete/dubbo-zookeeper-demo.git]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea远程一键部署springboot到Docker]]></title>
    <url>%2F2019%2F10%2F06%2FIdea%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2springboot%E5%88%B0Docker%2F</url>
    <content type="text"><![CDATA[** Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？** 一、 开发前准备 Docker的安装可以参考https://docs.docker.com/install/ 配置docker远程连接端口 1vi /usr/lib/systemd/system/docker.service 找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375，如下图所示 重启docker 12systemctl daemon-reloadsystemctl restart docker 开放端口 1firewall-cmd --zone=public --add-port=2375/tcp --permanent Idea安装docker插件,重启 连接远程docker(1) 编辑配置(2) 填远程docker地址(3) 连接成功，会列出远程docker容器和镜像 二、新建项目 创建springboot项目 项目结构图(1) 配置pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dockerDemo&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;web&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;copy todir="src/main/docker" file="target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;"&gt;&lt;/copy&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; (2) 在src/main目录下创建docker目录，并创建Dockerfile文件 123FROM openjdk:8-jdk-alpineADD *.jar app.jarENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] (3) 在resource目录下创建application.properties文件 123logging.config=classpath:logback.xmllogging.path=/home/developer/app/logs/server.port=8990 (4) 创建DockerApplication文件 123456@SpringBootApplicationpublic class DockerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DockerApplication.class, args); &#125;&#125; (5) 创建DockerController文件 123456789@RestControllerpublic class DockerController &#123; static Log log = LogFactory.getLog(DockerController.class); @RequestMapping("/") public String index() &#123; log.info("Hello Docker!"); return "Hello Docker!"; &#125;&#125; (6) 增加配置命令解释Image tag : 指定镜像名称和tag，镜像名称为 docker-demo，tag为1.1Bind ports : 绑定宿主机端口到容器内部端口。格式为[宿主机端口]:[容器内部端口]Bind mounts : 将宿主机目录挂到到容器内部目录中。格式为[宿主机目录]:[容器内部目录]。这个springboot项目会将日志打印在容器 /home/developer/app/logs/ 目录下，将宿主机目录挂载到容器内部目录后，那么日志就会持久化容器外部的宿主机目录中。 (7) Maven打包(8) 运行 这里我们可以看到镜像名称为docker-demo:1.1，docker容器为docker-server 参考https://www.toutiao.com/i6702260511217549832/ 文章，有改动]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取外部配置文件]]></title>
    <url>%2F2019%2F10%2F05%2FSpringBoot%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候项目打包成一个jar 或者war ,通过java -jar 命令运行springboot 项目，因为springboot项目有自己的application.properties配置文件，但是我们打完包之后，它也会打到包里边，倒是也能打开压缩包修改properties 文件，但是也是较为麻烦。 现在有如下需求，比如客户需要在很多个服务器部署一套项目，但是它们的数据库连接不一样，我们不能针对于这么多服务器，多次打包，很恶心，当然可以打完包，复制一堆，分别修改压缩包里边的配置文件。 springboot 有读取外部配置文件的方法，如下优先级： 第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。 第二种是直接把配置文件放到jar包的同级目录。 第三种在classpath下建一个config文件夹，然后把配置文件放进去。 第四种是在classpath下直接放配置文件。 看到如上的优先级了吗？也就是说springboot默认是优先读取它本身同级目录下的一个config/application.properties文件的。我们通常在src/main/resources 文件夹下创建的application.properties文件的优先级竟然是最低的！！！。 展示 新建Project（本人使用的是IDEA），很简单，此处不再赘述。 在项目根目录下新建config文件夹 在config文件夹下新建application.properties或application.yml文件如图所示： 此处的优先级大于src目录下的application.yml文件. 我们可以把一些公共的配置文件代码放置到此处，这样就达到配置文件代码解耦合的目的了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(二)]]></title>
    <url>%2F2019%2F09%2F20%2FHexo%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在进行了Hexo和GitPage搭建博客之后需要将本地博客推送到GitPage上，具体操作下面在文章内介绍。 一、注册Github&emsp;&emsp;首先如果你还没有 Github 账号的先注册一个，此处不赘述 二、创建仓库点击 Start project 或者下面的 new repository 创建一个新的仓库 注：由于我已经有相同的仓库名了 所以此处会报错，请忽略此错误 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 三、配置SSH Key要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。如有需要请自行Google，此处不再赘述 四、部署到Github此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。 第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）1234deploy: type: git repo: github: git@github.com:@@@/@@@.github.io.git 注： @@@/@@@ 需要修改为自己的链接 第二：要安装一个部署插件 hexo-deployer-git。 npm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦 12hexo ghexo d 命令提示： hexo g 生成环境hexo d 部署环境hexo s 启动服务预览]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(一)]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[作为一个程序员，个人博客可以说是不可或缺的。它可以记录自己技术成长的过程，也可以供别人参考、给他人提供方便，还可以锻炼自己的表达能力等等。这几年陆陆续续的在很多地方写过博客（CSDN、个人服务器），但是都有一些缺陷，所以最后决定用GitPage作为自己博客的新起点 Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。 一、准备环境&emsp;&emsp;1.node.js&emsp;&emsp;2.git安装非常简单 此处不再赘述&emsp;&emsp;安装验证： 123git versionnode -vnpm -v 二、安装Hexo在命令行输入执行以下命令： npm install -g hexo-cli 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 新建完成后，指定文件夹的目录如下： 1234567├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。hexo s 以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
</search>
