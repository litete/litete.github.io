<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用集合类(四) -- LinkedList]]></title>
    <url>%2F2019%2F10%2F28%2F%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E5%9B%9B-LinkedList%2F</url>
    <content type="text"><![CDATA[List 接口的链接列表实现。实现所有可选的列表操作，并且允许所有元素（包括 null）。除了实现 List 接口外， LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列&gt; 表用作堆栈、队列或双端队列。 此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。 所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一 端）。 注意，此实现不是同步的。如果多个线程同时访问一个链接列表，而其中至少一个线程从结构上修改了该列表，则它必须 &gt; 保持外部同步。（结构修改指添加或删除一个或多个元素的任何操作；仅设置元素的值不是结构修改。）这一般通过对自&gt; 然封装该列表的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedList 方法&gt; 来“包装”该列表。最好在创建时完成这一操作，以防止对列表进行意外的不同步访问，如下所示： List list = Collections.synchronizedList(new LinkedList(…));此类的 iterator 和 listIterator 方法返回的迭代器是快速失败 的：在迭代器创建之后，如果从结构上对列表进行修&gt; 改，除非通过迭代器自身的 remove 或 add 方法，其他任何时间任何方式的修改，迭代器都将抛出 &gt; ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来不确定的时间任 意发生不确定行为的风险。 注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何硬性保证。快速失败&gt; 迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的方式是错误的，正确做&gt; 法是：迭代器的快速失败行为应该仅用于检测程序错误。 源码解析LinkedList类定义123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。 LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 为什么要继承自AbstractSequentialList ? AbstractSequentialList 实现了get(int index)、set(int index, E element)、add(int index, E element) 和 remove(int index)这些骨干性函数。降低了List接口的复杂度。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了“get(int index)这些接口”。 此外，我们若需要通过AbstractSequentialList自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。 类成员变量12345678// 链表大小 transient int size = 0;// 首节点 transient Node&lt;E&gt; first;// 尾节点 transient Node&lt;E&gt; last; 其中node节点 1234567891011121314 // Node节点private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; // 下一个节点 this.next = next; // 上一个节点 this.prev = prev; &#125;&#125; 可以看到,linkedList采用了链表节点的方式实现,并且每个节点都有前驱和后驱节点 构造方法LinkedList 总共有 2 个构造方法： 12public LinkedList() &#123; &#125; 和 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 核心方法LinkedList 中与双向队列相关的几个方法为：offerFirst、offerLast、pollFirst、pollLast。 offerFirst : 将指定的元素插入此列表的开头1234567891011121314151617181920public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; //1 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //2 first = newNode; //3 if (f == null) //4 last = newNode; //5 else f.prev = newNode; //6 size++; modCount++;&#125; 解析linkFirst(E e): 现将first赋值给f 创建新节点 将新节点指向第一个节点 判断之前的头结点是否为空 如果为空,之前是一个空的节点,此时将last=newNode,使得此时的linkedList的last=first=newNode 如果不为空,将之前的头结点设为第二节点 offerLast : 将指定的元素插入此列表的结尾1234567891011121314151617181920public boolean offerLast(E e) &#123; addLast(e); return true;&#125;public void addLast(E e) &#123; linkLast(e);&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 将offerFirst中的first改为last,其余都一样 pollFirst : 检索并删除此列表的第一个元素1234567891011121314151617181920public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f); //1&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; // 2 else next.prev = null; // 3 size--; modCount++; return element;&#125; 如果第一个元素为空,则返回null,否则 将第一个元素传入unlinkFirst(f); 如果原首节点也是最后一个节点,则将linkedList的last也置为null 如果原首节点不是最后一个节点,则将下一个节点中的上一个节点信息置为null pollLast : 检测并删除此列表的最后一个元素1234567891011121314151617181920public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125;// 删除尾节点private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; 将pollFirst中的next改为prev,last改为first,其余都一样 addAll12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查是否越界 checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // 1 // pred为节点的上节点信息,succ为节点的下节点信息 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; // 将c添加到linkedList中 因为是添加,所以只考虑上节点信息就可以了 for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 快速查找到index所在位置,并根据x的位置赋值next或prev(如果index小于size的一半,则证明next一定有值,反之则证明prev一定有值)]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用集合类(三) -- ArrayList]]></title>
    <url>%2F2019%2F10%2F26%2F%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%B8%89-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList继承自abstractList 是线程不安全的。 ArrayList的创建ArrayList内部的成员变量123456789101112131415161718192021222324 /** （默认初始化长度）ps：实际是“延时初始化”（lazy init），后文详解 */private static final int DEFAULT_CAPACITY = 10; /** （共享空数组，为了追求效率） */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** （区别于EMPTY_ELEMENTDATA，使用默认构造方法时，默认使用此空数组，再配合DEFAULT_CAPACITY共同实现lazy init） */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** （集合数据真正存放的地方，所以对于ArrayList我们可以理解为提供了一组高效操作方法的数组。当集合的首个元素被添加时，把空集合DEFAULTCAPACITY_EMPTY_ELEMENTDATA扩展为DEFAULT_CAPACITY大小的集合，这就是lazy init，使用时才分配内存空间，目的是防止空间的浪费。）ps：transient 表示此变量不参与序列化 */transient Object[] elementData; // non-private to simplify nested class access /** （数组大小） */private int size; ArrayList有三种构造器 无参构造器123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 其中 DEFAULTCAPACITY_EMPTY_ELEMENTDATA源码: 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 由此可见,无参构造只是构建了一个空的ArrayList,此时size为0. 指定了容量的构造器12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; 解析: initialCapacity为指定的容量 如果大于0 则创建一个容量为initialCapacity的Object数组 如果等于0 则共享空数组，为了追求效率 如果小于0 抛出异常 构造一个包含指定元素的列表的构造器1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 解析: 首先调用ArrayList的父类AbstractCollection的toArray()方法将c变为Object数组 1234567891011public Object[] toArray() &#123; // Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) &#123; if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); &#125; return it.hasNext() ? finishToArray(r, it) : r; &#125; 然后判断: 假如此时数组的长度不等于0且其不是Object类,则将其拷贝然后赋值 假如数组长度等于0,则直接共享空数组. **但是准确的说这有个bug,这个bug在jdk9修复,bug产生原因后面详解。附上链接 常用方法解析 trimToSizetrimToSize方法将当前list的容量修改为列表当前的大小,用来最大程度的减小list的存储空间12345678public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; 解析: 如果list的size小于其容量,则根据其size是否为0选择将size赋值为0还是讲当前数组内容复制,容量为size小的的新数组返回给elementData. rangeCheck(int index) 1234private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 检查index是否越界,越界则抛出异常 get(int index)12345public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; 123E elementData(int index) &#123; return (E) elementData[index];&#125; 解析: ① 检查数组是否越界② 直接取出数组elementData相应位置index的元素并强转为E set(int index, E element)1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; 解析:① 判断index是否越界 ② 取到index位置的值作为原值 ③ 设置该位置值为修改后的值 ④ return原值 add(E e) add方法用到了刚才说的懒加载(lazy init),先说一下思路,然后按照思路看源码更容易理解一些. ① 判断是否需要lazy init,如果需要就init ② 判断是否需要扩容,如果需要执行步骤③,否则执行步骤⑤ ③ 扩容.日新数组长度=当前数组长度*1.5,并判断扩容后长度是否满足目标容量,不满足则新数组长度=目标容量.接着判断新数组长度是否超过阈值MAX_ARRAY_SIZE,超过则执行步骤④④ 目标数组长度=如果目标数组长度&gt;MAX_ARRAY_SIZE?Integer.MAX_VALUE:MAX_ARRAY_SIZE ⑤ 扩容结束后,执行数据copy,从原数组copy到新数组 ⑥ 在指定位置添加元素,是长度增加. 12345678910111213141516171819202122232425262728293031323334353637public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 这里解析一下ArrayList(MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8) 为什么无法创建更大的数组？Attempts to allocate larger arrays may result in OutOfMemoryError 如果数组长度过大，可能出现的两种错误 OutOfMemoryError: Java heap space 堆区内存不足（这个可以通过设置JVM参数 -Xmx 来指定）。 OutOfMemoryError: Requested array size exceeds VM limit 超过了JVM虚拟机的最大限制，我的window64就是 Integer.MAX_VALUE-1 . （这些内容涉及到JVM虚拟机知识，以后再进一步补充） 为什么数组长度的最大值是Integer.MAX_VALUE - 8 数组作为一个对象，需要一定的内存存储对象头信息，对象头信息最大占用内存不可超过8字节。 对象头信息Object head words 数组的对象头信息相较于其他Object，多了一个表示数组长度的信息。 具体的对象头内容，可以参考 JVM分析 remove(int index)1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 1.越界检测 2.取出当前位置的元素 3.当前位置之后的所有元素整体前移一位置 4.最后位置置空，size–，返回删除的元素值。 12345678910111213141516public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 12345678private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; 解析: 思路很简单，按元素删除（注意只删除从头开始第一个匹配值），遍历-&gt;匹配-&gt;删除 值得注意的是，单独对null做特殊处理，按地址比较. removeAll(Collection&lt;?&gt; c) 123456789101112131415161718192021222324252627282930313233343536373839public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false); &#125; private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123;//遍历当前集合所有元素 for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement)//如果指定集合不包含该元素（即不应删除的，需要保留的），把当前元素移动到头部w位置（原头部元素因不符合条件，直接删除掉，这里覆盖也即删除），并把w标记移到下一位 elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws.//这儿两种情况：//无异常r==size 不会进入这个if//有异常，则把因异常而未来得及比较的所有元素整体copy到w位置，并把w标记移位size - r（可以理解为还未比较的数量） if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125;//这儿很好理解，w位置（该位置之前都是比较或者异常而需要保留的）之后的所有都是应该删除的。 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified; &#125; 这个比较麻烦,所以注解都在代码上面了 如何保证ArrayList的线程安全 继承ArrayList,然后重写或按需求编写自己的方法,这些方法要写成synchronized,在这些synchromized的方法中调用ArrayList的方法 使用Collections.syncronizedList 使用方法如下假如你创建的代码如下： 1List&lt;Map&lt;String,Object&gt;&gt; data=new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); 那么为了解决这个线程安全问题你可以这么使用Collections.synchronizedList()，如： 1List&lt;Map&lt;String,Object&gt;&gt; data=Collections.synchronizedList(new ArrayList&lt;Map&lt;String,Object&gt;&gt;()); 其他的都没变，使用的方法也几乎与ArrayList一样，大家可以参考下api文档； 额外再说下 ArrayList与LinkedList；这两个都是接口List下的一个实现，用法都一样，但用的场所的有点不同，ArrayList适合于进行大量的随机访问的情况下使用，LinkedList适合在表中进行插入、删除时使用，二者都是非线程安全，解决方法同上（为了避免线程安全，以上采取的方法，特别是第二种，其实是非常损耗性能的）。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用集合类(二) -- AbstractList]]></title>
    <url>%2F2019%2F10%2F26%2F%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB-%E4%BA%8C%20--%20AbstractList%2F</url>
    <content type="text"><![CDATA[ArrayList和LinkedList都继承自abstractList 都是线程不安全的。 abstractList 提供checkForComodification方法（next，add，remove方法中都有调用此方法），在单线程中，遍历的时候删除List（for循环和增强for循环都不是正确做法，迭代器遍历才是正确的，博客后面有例子声明）。当两个线程有冲突时，（当一个线程使用迭代器遍历的时候，另一线程add，remove时，都会改变modcount值。）会抛出ConcurrentModificationException异常。 1234private void checkForComodification() &#123; if (this.modCount != l.modCount) throw new ConcurrentModificationException();&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用集合类(一) -- 综述]]></title>
    <url>%2F2019%2F10%2F26%2F%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[集合类在java开发中有着非常高的频率,它弥补了数组的缺陷,且比数组更灵活更实用,使用场景也比数组更广泛.所以选择合适的集合类对于性能的提升是很大的. Collection 介绍 Collection接口是可以理解成动态的数组和集合,与数组类似,但不同的是集合可以任意扩充大小 Collection是最基本的接口,如上图所示,List和Set类都是继承于它 特点 性能高 易扩展 易修改 ListList接口及其实现类是容量可变的列表，可按索引访问集合中的元素。 特点: List接口可以存放任意的数据，且在接口中，内容可以重复 List中提供了高效的插入和移除多个元素的方法 列表在数据结构中分别表现为：数组和向量、链表、堆栈、队列。 List常用（实现）子类 ArrayList（实现类） ArrayList 数组结构，插入移除数据慢，查询数据快，按索引查找，不是线程安全的。 contains复杂度为O(n)，add复杂度为分摊的常数，即添加n个元素需要O(n)时间，remove为O(n)，get复杂度为O(1) 例：list 12345678910- LinkedList(实现类)LinkedList 链表结构，插入移除数据块，只需要替换首尾节点地址就行，查询数据慢，需要按列表节点顺序依次查找。不是线程安全,可以当作堆栈、队列、双向队列来使用.例: ist list1=new LinkedList();- Vector（实现类）Vector跟ArrayList是类似的，内部实现也是动态数组，随机访问效率高,，有序，可重复，。Vector是线程安全的。例：```List list = new Vector&lt;&gt;(); ArrayList 和 Vector 的区别：（1）：Vector是线程安全的，源码中有很多的synchronized可以看出，而ArrayList不是。导致Vector效率无法和ArrayList相比； （2）：ArrayList和Vector都采用线性连续存储空间，当存储空间不足的时候，ArrayList默认增加为原来的50%，Vector默认增加为原来的一倍； （3）：Vector可以设置capacityIncrement，而ArrayList不可以，从字面理解就是capacity容量，Increment增加，容量增长的参数。 使用场景 对于需要快速插入、删除元素，应该使用LinkedList 对于需要快速随机访问元素，应该使用ArrayList 如果List需要被多线程操作，应该使用Vector，如果只会被单线程操作，应该使用ArrayList SetSet接口可以存放任意的数据，且在接口中，数据不可以重复（注意和List进行区别） 特点 无序 不重复 HashSet 能够快速定位一个元素。存入HashSet中的对象必须实现HashCode方法 常用实现类 HashSet HashSet内部是使用HashMap实现的，HashSet的key值是不允许重复的，如果放入的对象是自定义对象，那么最好能够同时重写hashCode与equals函数，这样就能自定义添加的对象在什么样的情况下是一样的，即能保证在业务逻辑下能添加对象到HashSet中，保证业务逻辑的正确性。另外，HashSet里的元素不是按照顺序存储的。HashSet是非线程安全的。 sets123456- TreeSetTreeSet存储的元素是按顺序存储的，如果是存储的元素是自定义对象，那么需要实现Comparable接口。TreeSet也是非线程安全的。``` Set sets=new TreeSet&lt;&gt;(); HashSet和TreeSet的区别: HashSet与TreeSet都是间接实现了Set接口，同样拥有add、remove等方法 HashSet是无序存放的、而TreeSet实现是有序存放（ASCII顺序存放） MapMap是一种把键对象和值对象进行关联的一种容器。 特点: 数据是以键值对的形式存放，例如： key -&gt; value “name” -&gt; “尼古拉斯赵四” key不允许重复。 键（key）的类型要一致，值（value）的类型也要一致。 常用实现类 HashMap HashMap 实现一个键到值映射的哈希表，通过键取得对象，没有顺序，通过get(key)来获取value，允许存储空对象，而且允许键是空(由于键必须是唯一，当然只能有一个)。 HashMap存储键值对。当程序试图将一个key-value对放入 HashMap 中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：如果两个Entry的key的hashCode() 返回值相同，那它们的存储位置相同。如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的 value，但key不会覆盖。如果这两个Entry的key通过equals 比较返回false，新添加的Entry将与集合中原有Entry形成Entry 链，而且新添加的 Entry 位于 Entry 链的头部。 HashMap允许key、value值为null。HashMap是非线程安全的。 初始化代码: 12345Map&lt;String,String&gt; maps = new HashMap&lt;&gt;();maps.put(&quot;name&quot;,&quot;詹姆斯刘能&quot;);maps.put(&quot;age&quot;,&quot;24&quot;); HashTable HashTable 实现一个映像，所有的键必须非空，线程安全。如果处理的数据比较大，可以考虑concurrentHashMap,采用分片加锁，提高程序运行效率。 HashMap与HashSet: Hashtable是HashMap的线程安全版本。而且，key、value都不允许为null。 Hashtable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 TreeMap TreeMap 实现排序。 ConcurrentHashMap ConcurrentHashMap 线程安全，比hashtable效率高，内部实现是分片锁定。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中各种关键字]]></title>
    <url>%2F2019%2F10%2F26%2FJava%E4%B8%AD%E5%90%84%E7%A7%8D%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[transienttransient的作用及使用方法java中的transient关键字为我们提供了便利,只需要实现Serilizable接口,将不需要序列化的属性前天健关键字transient,序列化对象的时候,这个属性就不会序列化到指定的目的地中. 示例code如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername(&quot;Alexia&quot;); user.setPasswd(&quot;123456&quot;); System.out.println(&quot;read before Serializable: &quot;); System.out.println(&quot;username: &quot; + user.getUsername()); System.err.println(&quot;password: &quot; + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(&quot;C:/user.txt&quot;)); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( &quot;C:/user.txt&quot;)); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(&quot;\nread after Serializable: &quot;); System.out.println(&quot;username: &quot; + user.getUsername()); System.err.println(&quot;password: &quot; + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 输出为： 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null 密码字段为null，说明反序列化时根本没有从文件中获取到信息。 transient使用小结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername(&quot;Alexia&quot;); user.setPasswd(&quot;123456&quot;); System.out.println(&quot;read before Serializable: &quot;); System.out.println(&quot;username: &quot; + user.getUsername()); System.err.println(&quot;password: &quot; + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(&quot;C:/user.txt&quot;)); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; // 在反序列化之前改变username的值 User.username = &quot;jmwang&quot;; ObjectInputStream is = new ObjectInputStream(new FileInputStream( &quot;C:/user.txt&quot;)); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(&quot;\nread after Serializable: &quot;); System.out.println(&quot;username: &quot; + user.getUsername()); System.err.println(&quot;password: &quot; + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 运行结果为： before Serializable: 123456username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null 这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。 transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？思考下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;/** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */public class ExternalizableTest implements Externalizable &#123; private transient String content = &quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File(&quot;test&quot;))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( &quot;test&quot;))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是： 是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExterna方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变content初始化的内容，而不是null。 final final 在 Java 中是一个保留的关键字，可以声明变量、方法、类。 当用 final 修饰一个类时，表明这个类不能被继承。 使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。final方法是静态绑定的，在编译时候就确定是哪个类的方法，所以比非final方法快一些。 final修饰的常量普通变量不可变，修饰的引用变量不可变，引用对象的内容可以改变。 使用final的优点：final方法比非final快一些final关键字提高了性能。JVM和Java应用都会缓存final变量。final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。使用final关键字，JVM会对方法、变量及类进行优化。 final关键字图解 Override的作用@Override是伪代码,表示重写(当然不写也可以)，不过写上有如下好处: 可以当注释用,方便阅读； 编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。 finally异常处理的执行顺序（针对try{}catch{}finally{}而言）对于try{}catch{}finally{}而言，它们的执行顺序很简单，如果在try{}中捕获相应的异常，中断当前代码的执行，转而去执行catch{}中的内容，最后去执行 finally{}中方法，一般来说finally中的方法都是会被执行的，其中finally中很大程度上用于资源的释放。 下面讲解一些我们java程序员需要注意的地方。 finally中的代码总是会执行吗？ 答：no，如果一个方法内在执行try{}语句之前就已经return了，那么finally语句指定不会执行了。因为它根本没有进入try语句中如果在一个try语句中调用System.exit(0);方法，那么就会退出当前java虚拟机，那么finally也就没有执行的机会了。 finally在return之前执行还是在return之后执行？答：很多人可能会说在return执行之前执行。我的答案是在return中间执行，是不是很特别。具体参见[java中finally执行顺序]{https://www.cnblogs.com/xiohao/p/4278405.html} 观察以下代码： 123456789101112131415161718192021222324252627282930package FileUtil;public class finallyTest &#123; public static int method()&#123; int x=1; try&#123; return x; &#125;catch(Exception e) &#123; return 0; &#125;finally&#123; ++x; &#125; &#125; public static int method2()&#123; int x=1; try&#123; return x++; &#125;catch(Exception e) &#123; return 0; &#125;finally&#123; return ++x; &#125; &#125; public static void main(String[] args) &#123; System.out.println(method());//1 System.out.println(method2());//3 &#125;&#125; 输出分别是1和3。 method()：首先程序在执行到try{}语句中的return方法后，就会先返回相应的值，并把相应的值存储在一个临时栈中去保存这个结果。这时临时栈中存储的值为1。但是程序不会立刻返回，转而回去执行finally中的方法，++x，在finally执行完后，方法全部执行完，这时会再次调用return方法，注意这时 不在是返回值，而是告诉主调程序，被调程序已经执行完了，你可以接着去执行你主程序的其它方法了。但是请注意，此时返回的值还是原来保存在临时栈中的值1。method2():这里在try{}语句中执行到return会在临时栈中存储值返回值的变量。接着回去执行finally里面的内容，这时执行finally中的return方法，这时 临时栈中的值就是变为 3，会覆盖原来临时栈中的值1.所以它的返回值为3。 转载作者: https://blog.csdn.net/qq_43502142/article/details/88815710]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中几种常量池]]></title>
    <url>%2F2019%2F10%2F26%2FJava%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[在java的内存分配中,经常听到很多关于常量池的描述,我开始看的时候也是看的很模糊,网上五花八门的说法太多了,最后查阅&lt;&lt;深入了解JAVA虚拟机&gt;&gt;,差不多是理清了,很多网上说法都是有问题的,下面我就来区分一下这几个概念. 全局字符串池(String pool也叫做string literal pool)全局字符串池里的内容是在类加载完成,经过验证.,准备阶段之后在堆中生成的字符串对象实例,然后将该字符串对象实例的引用值存到string pool中(记住:string pool中村的是引用值而不是具体的实例对象,具体的实例对象实在对中开辟的一块内存空间存放的). 在HotSpot VM里实现的string pool功能的是一个StringTable类,它是一个哈希表,里面存的是驻留字符串(也就是我们常说的用双括号引起来的)的引用(而不是驻留字符串实例本身),也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份.这个StringTable在每个HotSpot VM的实例只有一份,被所有的类共享. class文件常量池(class constant pool)我们都知道,class文件中除了包含类的版本,字段,方法,接口等描述信息外,还有一项信息就是常量池(constant pool table),用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References). 字面量就是我们常说的常量概念,如文本字符串,被声明的final的常量值等. 符号引用是一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义的定位到目标即可(它与直接引用区分一下,直接引用一般是指向方法区的本地指针,相对于偏移量或是一个能间接定位到目标的句柄).一般包括下面三类常量: 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 常量池的每一项常量就是一个表,一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。每种不同类型的常量类型具有不同的结构，具体的结构本文就先不叙述了，本文着重区分这三个常量池的概念（读者若想深入了解每种常量类型的数据结构可以查看《深入理解java虚拟机》第六章的内容）。 运行时常量池（runtime constant pool）当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？ jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。 举个实例来说明一下: 12345678String str1 = &quot;abc&quot;;String str2 = new String(&quot;def&quot;);String str3 = &quot;abc&quot;;String str4 = str2.intern();String str5 = &quot;def&quot;;System.out.println(str1 == str3);//trueSystem.out.println(str2 == str4);//falseSystem.out.println(str4 == str5);//true 上面程序的首先经过编译之后，在该类的class常量池中存放一些符号引用，然后类加载之后，将class常量池中存放的符号引用转存到运行时常量池中，然后经过验证，准备阶段之后，在堆中生成驻留字符串的实例对象（也就是上例中str1所指向的”abc”实例对象），然后将这个对象的引用存到全局String Pool中，也就是StringTable中，最后在解析阶段，要把运行时常量池中的符号引用替换成直接引用，那么就直接查询StringTable，保证StringTable里的引用值与运行时常量池中的引用值一致，大概整个过程就是这样了。 回到上面的那个程序，现在就很容易解释整个程序的内存分配过程了，首先，在堆中会有一个”abc”实例，全局StringTable中存放着”abc”的一个引用值，然后在运行第二句的时候会生成两个实例，一个是”def”的实例对象，并且StringTable中存储一个”def”的引用值，还有一个是new出来的一个”def”的实例对象，与上面那个是不同的实例，当在解析str3的时候查找StringTable，里面有”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同，str4是在运行的时候调用intern()函数，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值，最后str5在解析的时候就也是指向存在于StringTable中的”def”的引用值，那么这样一分析之后，下面三个打印的值就容易理解了。 总结 全局常量池在每个VM中只有一份，存放的是字符串常量的引用值。 class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 两个对象不同为什么他们的hashcode有可能相同]]></title>
    <url>%2F2019%2F10%2F25%2FJAVA-%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%90%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%96%E4%BB%AC%E7%9A%84hashcode%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9B%B8%E5%90%8C%2F</url>
    <content type="text"><![CDATA[哈希表是结合了直接寻址和链式寻址两种方式，所需要的就是将需要加入哈希表的数据首先计算哈希值，其实就是预先分个组，然后再将数据挂到分组后的链表后面，随着添加的数据越来越多，分组链上会挂接更多的数据，同一个分组链上的数据必定具有相同的哈希值，java中的hash函数返回的是int类型的，也就是说，最多允许存在2^32个分组，也是有限的，所以出现相同的哈希码就不稀奇了 这段话简易来说就是,hash算法不能为每一条数据分配一个独有的hashcode值,因此会有重复.比如: 比如说你用身份证判断equal, hashcode = 身份证每一位的数字的综合。 甲的身份证是 12345 乙的身份证是 54321 这样甲和乙的hashcode 都是以一样的 1 + 2+ 3+ 4+ 5 = 15但是 12345 不equals 54321]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Switch对String的支持]]></title>
    <url>%2F2019%2F10%2F25%2FSwitch%E5%AF%B9String%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[switch对整型的支持先看一段简单的源码: 12345678910111213int i = 3; switch (i) &#123; case 1: System.out.println(1); break; case 3: System.out.println(3); break; default: System.out.println(&quot;error&quot;); break; &#125; 输出: 3 反编译后代码: 1234567891011int i = 3; switch(i) &#123; case 1: System.out.println(1); break; case 3: System.out.println(3); break; default: System.out.println(&quot;error&quot;); &#125; 代码基本相同,由此可见,Switch对整型的判断是直接整数的值 Switch对字符型的支持先看一段代码: 12345678910111213char a = &apos;b&apos;; switch (a) &#123; case &apos;a&apos;: System.out.println(&apos;a&apos;); break; case &apos;b&apos;: System.out.println(&apos;b&apos;); break; default: System.out.println(&quot;error&quot;); break; &#125; 编译后代码: 1234567891011char a = 98; switch(a) &#123; case 97: System.out.println(&apos;a&apos;); break; case 98: System.out.println(&apos;b&apos;); break; default: System.out.println(&quot;error&quot;); &#125; 由上可见,对char类型的比较,实际上是比较的ascii码,编译器会把char变量转换成对应的int变量比较 switch对字符串的支持代码 123456789101112String str = &quot;world&quot;; switch (str) &#123; case &quot;hello&quot;: System.out.println(&quot;hello&quot;); break; case &quot;world&quot;: System.out.println(&quot;world&quot;); break; default: break; &#125; 对代码反编译: 123456789101112131415161718192021String str = &quot;world&quot;;byte var3 = -1;switch(str.hashCode()) &#123;case 99162322: if (str.equals(&quot;hello&quot;)) &#123; var3 = 0; &#125; break;case 113318802: if (str.equals(&quot;world&quot;)) &#123; var3 = 1; &#125;&#125;switch(var3) &#123;case 0: System.out.println(&quot;hello&quot;); break;case 1: System.out.println(&quot;world&quot;);&#125; 由此可见,switch对于字符串的支持是通过equals()和hashcode()实现的.因为switch的判断条件只能是等于，所以对于数据类型的精度要求比较高,所以Switch表达式中只能是整形,比如byte,short,char和int.所以switch中使用hashcode值,但是众所周知,不同的值对应的hashcode有可能相同,所以,在switch方法体中,还需要使用equals()来进行最后的确认. 总结switch表达式只支持一种类型:整型,所以 char要转换成对应的ascii码 string要转成对应的hashcode值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类常用方法源码分析]]></title>
    <url>%2F2019%2F10%2F24%2FString%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[环境: JDK8 String先看String类的定义 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence 可以看到String类被final修饰,因此不能被继承.String类还实现了序列化接口Serializable,可比较的接口Comparable并指定泛型String,该接口必须实现int compareTo方法,最后还实现了字符序列CharSequence的接口,该接口常用的方法如chatAt(int index),length(),toString()等等. 构造字符串String类的无参构造函数 12345678/** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */public String() &#123; this.value = &quot;&quot;.value;&#125; 其中value定义: 12/** The value is used for character storage. */ private final char value[]; 该构造函数创建了一个空的字符换并存在字符数组value中. 再看看一个有参的构造函数: 123456789101112/** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */ public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; 该构造函数指定一个字符数组来创建一个字符序列,是通过Arrays的copyOf方法将字符数组拷贝到当前数组. 这样当修改字符数组的子串时,不会影响新字符数组. 下面经过一个简单的测试来验证下 12345678910111213141516public static void main(String[] args) &#123; char[] c1 = &#123;&apos;a&apos;, &apos;b&apos;&#125;; char[] c2 = c1; for (int i = 0; i &lt; c1.length; i++) &#123; if (i==1)&#123; c1[1]=&apos;c&apos;; &#125; &#125; for (char c : c1) &#123; System.out.println(&quot;c1:&quot;+c); &#125; for (char c : c2) &#123; System.out.println(&quot;c2:&quot;+c); &#125; &#125; 结果 1234c1:ac1:cc2:ac2:c 由上可知,在c1赋值给c2后,改变了c1中的值c2的值也会随之变化,这显然与我们想要的相悖,所以才会使用拷贝的方式,将c1与c2分开. 经过以上分析可以看出,下面两个语句是等价的,因为String类底层使用char[]数组来存储字符序列. 12char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;String str = new String(data); string.value.length的代码等价于string.length123public int length() &#123; return value.length; &#125; 使用字节数组构造一个String在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。 String(byte[] bytes, Charset charset) 是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。 这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式。 如果我们在使用byte[]构造String的时候，使用的是下面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下： 12345678910111213141516171819static byte[] encode(String charsetName, char[] ca, int off, int len) throws UnsupportedEncodingException &#123; StringEncoder se = deref(encoder); String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName; if ((se == null) || !(csn.equals(se.requestedCharsetName()) || csn.equals(se.charsetName()))) &#123; se = null; try &#123; Charset cs = lookupCharset(csn); if (cs != null) se = new StringEncoder(cs, csn); &#125; catch (IllegalCharsetNameException x) &#123;&#125; if (se == null) throw new UnsupportedEncodingException (csn); set(encoder, se); &#125; return se.encode(ca, off, len);&#125; 上面是编码清单，下面是解码清单： 12345678910111213141516171819static char[] decode(String charsetName, byte[] ba, int off, int len) throws UnsupportedEncodingException &#123; StringDecoder sd = deref(decoder); String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName; if ((sd == null) || !(csn.equals(sd.requestedCharsetName()) || csn.equals(sd.charsetName()))) &#123; sd = null; try &#123; Charset cs = lookupCharset(csn); if (cs != null) sd = new StringDecoder(cs, csn); &#125; catch (IllegalCharsetNameException x) &#123;&#125; if (sd == null) throw new UnsupportedEncodingException(csn); set(decoder, sd); &#125; return sd.decode(ba, off, len);&#125; charAt再看charAt（int index）方法源码： 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; 该方法返回字符序列中下标为index的字符。并且index的范围：(0,value.length]. concat先看源码: 12345678910public String concat(String str) &#123; int otherLen = str.length(); //取得str字符串长度 if (otherLen == 0) &#123; //如果传入的字符串内容为空，则返回原字符串 return this; &#125; int len = value.length; //取得原字符串内容的长度 char buf[] = Arrays.copyOf(value, len + otherLen); //复制字符串的内容到char数组，并扩展长度 str.getChars(buf, len); //将str的内容复制到buf数组中，位置从len开始。在这一步完成两个字符串的拼接 return new String(buf, true); //将buf数组转化为新的String实例并返回 &#125; 步骤含义基本都在上面,这里着重描述一下getChars方法 123void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length); &#125; 可以看出,链接字符换操作实际是字符串的拷贝.最后返回连接成功后的字符串. 最后是一个特殊的私有包范围类型的构造方法，String除了提供了很多公有的供程序员使用的构造方法以外，还提供了一个包范围类型的构造方法（Jdk 8），我们看一下他是怎么样的： 1234String(char[] value, boolean share) &#123; // assert share : &quot;unshared not supported&quot;; this.value = value;&#125; 从代码中我们可以看出，该方法和 String(char[] value)有两点区别： 第一个，该方法多了一个参数： boolean share，其实这个参数在方法体中根本没被使用，也给了注释，目前不支持使用false，只使用true。那么可以断定，加入这个share的只是为了区分于String(char[] value)方法，不加这个参数就没办法定义这个函数，只有参数不能才能进行重载。 第二个区别就是具体的方法实现不同。 那么也就是说，这个方法构造出来的String和参数传过来的char[] value共享同一个数组。 那么，为什么Java会提供这样一个方法呢？ 首先，我们分析一下使用该构造函数的好处： 首先，性能好，这个很简单，一个是直接给数组赋值（相当于直接将String的value的指针指向char[]数组），一个是逐一拷贝。当然是直接赋值快了。 其次，共享内部数组节约内存。 该方法之所以设置为包范围，是因为一旦该方法设置为公有，在外面可以访问的话，那就破坏了字符串的不可变性。 subStringsubstring有两个重载方法： 12345678910public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); &#125; 1234567891011121314public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; 这两个重载方法都是先计算要截取的子串长度，判断边界最后返回调用new String(value, beginIndex, subLen)方法，我们来看一下这个方法： 12345678910111213141516171819public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = &quot;&quot;.value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; offset指第一个匹配的字符序列的索引，count指子串的长度。最终该子串会被拷贝到字符数组value中，并且后续的字符数组的修改并不影响新创建的字符串。 contains先看一下源码: 123public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1;&#125; 可以看出,直接调用indexOf方法: 123public int indexOf(String str) &#123; return indexOf(str, 0);&#125; 1234public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; 12345678910111213141516171819202122232425262728293031323334353637static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; 首先判断开始索引如果大于源字符串则返回，若目标字符串长度为0返回源字符串长度，否则返回-1. 然后迭代查找字符，若全部源字符串都找到则返回第一个匹配的索引，否则返回-1.所以在public boolean contains(CharSequence s)方法中，若indexOf方法返回-1则返回false，否则返回true。 equals源码: 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; 该方法首先判断this == anObject ？，也就是说判断要比较的对象和当前对象是不是同一个对象，如果是直接返回true，如不是再继续比较，然后在判断anObject是不是String类型的，如果不是，直接返回false,如果是再继续比较，到了能终于比较字符数组的时候，他还是先比较了两个数组的长度，不一样直接返回false，一样再逐一比较值。 join12345678910public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString();&#125; StringJoiner 类也是jdk1.8开始加入的通过分隔符或前缀或后缀来构造字符串的，底层是字符序列的拷贝。 requireNonNull方法校验参数不能为空,否则抛异常.源码: 12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125; lastIndexOf lastIndexOf(String str)与lastIndexOf(String str, int fromIndex) lastIndexOf(String str)方法返回字符串str在String中最后出现的起始的位置lastIndexOf(String str, int fromIndex)方法返回在fromIndex位置之后字符串str在String中最后出现的起始的位置 lastIndexOf(String str)源码: 123public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length);&#125; lastIndexOf(String str, int fromIndex)源码: 1234public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; 由上可见,lastIndexOf(String str)也是调用的lastIndexOf(String str, int fromIndex)方法,只不过fromIndex参数是String的长度 看到这时会产生一个疑问,fromIndex是String的长度了,那怎么还能查到lastIndexOf的值呢? 带着这个疑问,继续往下看 123456789101112131415161718192021222324252627282930313233343536373839404142static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex; startSearchForLastChar: while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125; &#125; 我们来逐步解析源码 source : 被搜索的字符 sourceOffset : 源字符串的偏移量 sourceCount : 源字符串的计数 target : 要搜索的字符 targetOffset : 目标字符串的偏移量 targetCount : 目标字符串的计数 fromIndex: 从index开始搜索的索引 12345int rightIndex = sourceCount - targetCount; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; rightIndex为被搜索字符与目标字符的差,我们可以先假设目标字符在被搜索字符的最后位置,假如此时fromIndex是上面的疑问中的被搜索字符的长度,那么就将这个差值赋值给fromIndex. 问:至于为什么要传入被搜索字符串的长度?答:为了保证在fromIndex的值一定要大于等于rightIndex,从而使fromIndex = rightIndex 提前要说一下: 此方法是按照被搜索字符从右往左的顺序匹配目标字符的的 1234int strLastIndex = targetOffset + targetCount - 1;char strLastChar = target[strLastIndex];int min = sourceOffset + targetCount - 1;int i = min + fromIndex; strLastIndex : 目标字符最大索引 strLastChar : 目标字符最大索引出所对应的值 min : 假设目标字符出现在最左边,min代表此时目标字符在被搜索字符的位置的索引 i : 被搜索字符的最大索引 1234567891011121314151617181920startSearchForLastChar: while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125; 中 123while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; 为了从右往左查找目标字符最后一位出现在被搜索字符的位置 12345678910int j = i - 1;int start = j - (targetCount - 1);int k = strLastIndex - 1;while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125;&#125; 继续从右往左第二位开始匹配,这里就不多说了. 参考文章: https://blog.csdn.net/u011726984/article/details/51326697]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字详解]]></title>
    <url>%2F2019%2F10%2F23%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[static关键字的用途 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途 — 摘自&lt;&lt;java编程思想&gt;&gt; 这段话用一句话来描述就是: 方便在没有创建对象的情况下来进行调用(方法/变量) 很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 static修饰方法 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 此时可以看到,静态方法print2不能访问非静态变量与非静态方法.而非静态方法print1可以不需要new直接访问print2方法. 由此可以看出,print2方法时独立于对象存在的,可以直接通过类名调用.例如: Class.print2(); static修饰变量 static变量也成为静态变量,静态变量和非静态变量的区别是:静态变量被所有的对象所共享,在内存中只有一个副本,它当且仅当在类初次加载时会被初始化.而非静态变量所拥有的,在创建对象的时候被初始化,存在多个副本,各个对象拥有的副本互不影响. static成员变量的初始化顺序按照定义的顺序进行初始化. static修饰代码块static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能. static块可以置于类中的任何地方,类中可以有多个static块.在类初次加载时,会按照static块ed顺序来执行每个static块,并且只执行一次. 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子: 12345678910111213class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(&quot;1946&quot;); Date endDate = Date.valueOf(&quot;1964&quot;); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好： 12345678910111213141516class Person&#123; private Date birthDate; private static Date startDate,endDate; static&#123; startDate = Date.valueOf(&quot;1946&quot;); endDate = Date.valueOf(&quot;1964&quot;); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 static关键字误区 static关键字会改变类中成员的访问权限吗？ ava中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。 能通过this访问静态成员变量吗？ 这里面主要考察队this和static的理解。this代表什么？this代表当前对象。而static变量是被对象所享有的，静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 static能作用于局部变量么？ static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。 常见的面试题 下面这段代码的输出结果是什么？12345678910111213141516171819202122232425public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125; 结果: 1234base statictest staticbase constructortest constructor 解析: 从main方法开始执行,先加载Test类 Test类继承Base类,因此先去加载Base类,发现有static代码块,便开始执行static代码块.此时输出: base static base类加载完成后,继续加载Test类,发现Test类中也有static方法,便开始执行static代码块,此时输出: test static 在加载完静态代码后,便继续执行main方法,在main方法中new Test()时会先调用父类的构造器,输出: base constructor 再调用自身的构造器,输出test constructor 这段代码的输出结果是什么？ 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; Person person = new Person(&quot;Test&quot;); static&#123; System.out.println(&quot;test static&quot;); &#125; public Test() &#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125; class Person&#123; static&#123; System.out.println(&quot;person static&quot;); &#125; public Person(String str) &#123; System.out.println(&quot;person &quot;+str); &#125;&#125; class MyClass extends Test &#123; Person person = new Person(&quot;MyClass&quot;); static&#123; System.out.println(&quot;myclass static&quot;); &#125; public MyClass() &#123; System.out.println(&quot;myclass constructor&quot;); &#125;&#125; 结果: 1234567test staticmyclass staticperson staticperson Testtest constructorperson MyClassmyclass constructor 先加载Test类,执行其中的static方法,输出:test static 再加载MyClass类中的static方法,输出:myclass static 在加载完static后,就通过构造器来生成对象.而在生成对象的时候,必须先初始化父类的成员变量,因此会执行Test中的Person person = new Person(),而Person类还没有被加载过,因此会先加载Person类中的static块,输出person static 继续执行Person的构造器,输出:person Test 继续执行Test类中的构造器,输出:test constructor.此时完成了父类的初始化 初始化自身,因此会继续执行MyClass中的Person person = new Person()，输出:person MyClass 执行myClass中的构造器,输出:myclass constructor 这段代码的输出结果是什么？12345678910111213public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; 结果: 12test static 1test static 2 初始化时加载静态代码块,其余不解释]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里的构造函数]]></title>
    <url>%2F2019%2F10%2F23%2Fjava%E9%87%8C%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Java里的构造函数(构造方法) 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们,即构造函数的重载。 构造函数的特点 ① 构造函数的主要作用是完成对象的初始化工作,如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数,它能够把定义对象时的参数传给对象的域.意即当创建一个对象时,这个对象就被初始化,如果这是构造函数不为空,则在创建对象时就执行构造函数里面的代码. ② 构造函数的名称必须与类名相同,不包括大小写; ③ 构造函数没有返回值,也不能用void修饰,如果加上了返回值类型,那么这将使这个构造函数变成一个普通的方法,在运行时将产生找不到构造方法的错误. ④ 一个类可以定义多个构造犯法,如果在定义类时没有定义构造方法,则编译系统会自动插入一个无参数的默认构造函数,这个构造器不执行任何代码 ⑤ 构造方法可以重载,以参数的个数,类型,顺序区分.⑥ 在函数的继承里,子类必须调用父类的构造函数.但是,子类只能继承父类的默认构造函数,如果父类没有默认构造函数,那子类不能从父类继承默认构造函数,这时子类必须使用super来实现对父类的为默认构造函数的调用.在创建对象时,先调用父类默认构造函数对对象进行初始化,然后调用子类自身定义的构造函数. 针对1中的⑥进行代码展示 父类: 123456789public class Class &#123; int age; String name; Class(int age, String name) &#123; this.age = age; this.name = name; &#125;&#125; 父类中使用有参的构造方法,此时不会生成默认的无参构造方法. 子类: 我们先让子类继承父类,会产生如下报错 可以看到,java让Student类中实现父类的构造方法,代码完成后是这样的: 这就是刚才说的,子类必须使用super来实现对父类的非默认构造方法的调用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps搭建shadowsocks]]></title>
    <url>%2F2019%2F10%2F23%2Fvps%E6%90%AD%E5%BB%BAshadowsocks%2F</url>
    <content type="text"><![CDATA[出于程序员的本能，我尝试在外网上搭建了一个VPN（搭建成功后就删除了，证明自己搭建成功过就满足了），现在记录一下步骤 一、 购买服务器 经过筛选，我选择了vultr服务器，每月5美元，建议地址选Tokyo，操作系统选centos7，最好不要选8，配置选最小即可，然后部署服务器二、 部署shadowsocks 这里使用的是秋水逸冰的Python版一键安装脚本，使用方法如下： 1. 使用root用户，运行如下命令123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 其中需要输入一些信息如IP、Port、password等，均可自己定义 安装完成后，脚本提示如下： 12345678 Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 单用户配置文件示例：配置文件路径：/etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例：配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 以上引用自 &gt; http://www.wangchao.info/1148.html 有改动 三、 KCPTun加速 搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。 KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。 KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 首先需要确认一下加速地址，大部分不能加速是因为加速地址配置错误 首先找到Shadowsocks端口，如8388，然后再命令行输入一下命令： 1netstat -nl | grep 8388 如果提示以上命令不存在，则输入 1ss -nl | grep 8388 然后你会看到类似下面的输出（着重看显示为红色的部分）： 情况一： 12tcp6 0 0 :::8388 :::* LISTEN udp6 0 0 :::8388 :::* 情况二： 12tcp 0 0 127.0.0.1:8388 :::* LISTEN udp 0 0 127.0.0.1:8388 :::* 情况三： 12tcp 0 0 0.0.0.0:8388 :::* LISTEN udp 0 0 0.0.0.0:8388 :::* 情况四： 12tcp 0 0 10.10.10.10:8388 :::* LISTEN udp 0 0 10.10.10.10:8388 :::* 情况五： 12udp UNCONN 0 0 *:1080 *:* tcp LISTEN 0 128 *:1080 *:* 若为情况1、情况2、情况5和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口） 若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口） Kcptun 一键安装脚本 12wget --no-check-certificate -O kcptun.sh https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.shsh kcptun.sh 同样也需要一些自定义配置,其中的加速IP按上面说的填写。 注： 填写完成后会提示按任意键继续和CTRL+C退出，此时要按任意键 如果安装成功，应该能看到如下信息 12345678910111213141516171819202122232425262728293031323334353637&gt; 恭喜, Kcptun 服务端配置完毕！&gt; &gt; 正在获取当前安装的 Kcptun 版本...&gt; &gt; 服务器IP: 10.10.10.10&gt; 端口: 29900&gt; 加速地址: 127.0.0.1:8388&gt; 密码: 123456&gt; 加密方式 Crypt: salsa20&gt; &gt; 当前安装的 Kcptun 版本为: v20160922&gt; &gt; 推荐的客户端配置为: &gt; &#123;&gt; &quot;localaddr&quot;: &quot;:8388&quot;,&gt; &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,&gt; &quot;key&quot;: &quot;123456&quot;,&gt; &quot;crypt&quot;: &quot;salsa20&quot;,&gt; &quot;mode&quot;: &quot;fast&quot;,&gt; &quot;mtu&quot;: 1350,&gt; &quot;sndwnd&quot;: 1024,&gt; &quot;rcvwnd&quot;: 1024,&gt; &quot;datashard&quot;: 10,&gt; &quot;parityshard&quot;: 3,&gt; &quot;dscp&quot;: 0,&gt; &quot;conn&quot;: 1,&gt; &quot;autoexpire&quot;: 60,&gt; &quot;nocomp&quot;: false&gt; &#125;&gt; &gt; 手机端参数可以使用：&gt; *******&gt; &gt; 其他参数请自行计算或设置, 详细信息可以查看: https://github.com/xtaci/kcptun&gt; &gt; Kcptun 安装目录: /usr/share/kcptun&gt; Kcptun 日志文件目录: /var/log/kcptun/ 请将以上的提示信息复制保存下来，后面配置客户端会用到这些提示信息。注意：服务端的 sndwnd 对应的是客户端的 recwnd，所以请不要问我为什么输出的客户端参数和你配置的服务端参数是反的。 安装之后，Kcptun 服务交由 Supervisor 管理。 Supervisor 相关命令： 1service supervisord &#123;start|stop|restart|status&#125; Kcptun 相关命令： 1supervisorctl &#123;start|stop|restart|status&#125; kcptun Supervisor 启动的时候会同时启动 Kcptun，运行 kcptun 相关命令时先确保 Supervisor 已启动。 四、客户端配置（windows，没有mac） 先下载一个Kcptun工具.按照kcptun执行完成以后保存的信息填入Kcptun中相关的位置 下载Shadowsocks，填写相关信息，注意：其中的密码和加密方式一定要与服务器shadowsocks配置的相同，否则不能联网。 到此位止，我的VPN就搭建好了，试一下可以访问谷歌而且很稳定。 在vultr上是按照时间付钱的，可以在不用的时候删掉服务器，不再扣钱。]]></content>
      <categories>
        <category>vps搭建shadowsocks</category>
      </categories>
      <tags>
        <tag>vps搭建shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建dubbo服务]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%90%AD%E5%BB%BAdubbo%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[dubbo目录结构如图所示：生产者为服务的被调用方生产者为服务的调用方API为生产者和消费者中间的桥梁，这个是必不可少的。原因： 如果没有API的话，消费者需要将生产者的包导入到本地仓库，这样就相当于把生产者的代码放到了本地，不符合微服务的理念 假如没有API的话，消费者需要将生产者的包导入到本地仓库，如果此时生产者的代码发生了变化，消费者必须每次手动清楚生产者的包进行重新导包，这样的设计是非常垃圾的。 假如有API的话，我们通过API远程调用生产者的接口，这样不管生产者的代码怎么变化，我们都是通过API调用的最新的代码。这种设计是才是合理的。一、POM。xml 根 pom.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;consumers&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;module&gt;providers&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;revision&gt;2.7.1&lt;/revision&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; providers pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;providers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; consumers pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;consumers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; api pom.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 二、 resources providers application.yml 1234567891011121314151617181920spring: application: name: providersdubbo: scan: base-packages: com.fengqi.providers.service protocol: name: dubbo port: 9010 registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8282demo: service: version: 1.0.0embedded: zookeeper: port: 2181 consumers application.yml 123456789101112131415161718spring: application: name: consumersdemo: service: version: 1.0.0embedded: zookeeper: port: 2181dubbo: registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8281 注： api不需要yml 三.、代码 providers 123456789101112131415161718 package com.fengqi.providers.service;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Service;import org.springframework.beans.factory.annotation.Value;@Service(version = "1.0.0")public class ApiServiceImpl implements ApiService &#123; @Value("$&#123;dubbo.application.name&#125;") private String serviceName; @Override public String sayHello(String name) &#123; return String.format("[%s] : Hello, %s", serviceName, name); &#125;&#125; consumers 1234567891011121314151617181920package com.fengqi.consumers.controller;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class ConsumersController &#123; @Reference(version = "1.0.0") private ApiService apiService; @GetMapping public String getProviders() &#123; return apiService.sayHello("李特"); &#125;&#125; api 12345package com.fengqi.api;public interface ApiService &#123; String sayHello(String name);&#125; 此时，一个多module的dubbo服务就已经完成了 ，运行看一下吧。 项目地址： https://github.com/litete/dubbo-zookeeper-demo.git]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea远程一键部署springboot到Docker]]></title>
    <url>%2F2019%2F10%2F06%2FIdea%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2springboot%E5%88%B0Docker%2F</url>
    <content type="text"><![CDATA[** Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？** 一、 开发前准备 Docker的安装可以参考https://docs.docker.com/install/ 配置docker远程连接端口 1vi /usr/lib/systemd/system/docker.service 找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375，如下图所示 重启docker 12systemctl daemon-reloadsystemctl restart docker 开放端口 1firewall-cmd --zone=public --add-port=2375/tcp --permanent Idea安装docker插件,重启 连接远程docker(1) 编辑配置(2) 填远程docker地址(3) 连接成功，会列出远程docker容器和镜像 二、新建项目 创建springboot项目 项目结构图(1) 配置pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dockerDemo&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;web&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;copy todir="src/main/docker" file="target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;"&gt;&lt;/copy&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; (2) 在src/main目录下创建docker目录，并创建Dockerfile文件 123FROM openjdk:8-jdk-alpineADD *.jar app.jarENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] (3) 在resource目录下创建application.properties文件 123logging.config=classpath:logback.xmllogging.path=/home/developer/app/logs/server.port=8990 (4) 创建DockerApplication文件 123456@SpringBootApplicationpublic class DockerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DockerApplication.class, args); &#125;&#125; (5) 创建DockerController文件 123456789@RestControllerpublic class DockerController &#123; static Log log = LogFactory.getLog(DockerController.class); @RequestMapping("/") public String index() &#123; log.info("Hello Docker!"); return "Hello Docker!"; &#125;&#125; (6) 增加配置命令解释Image tag : 指定镜像名称和tag，镜像名称为 docker-demo，tag为1.1Bind ports : 绑定宿主机端口到容器内部端口。格式为[宿主机端口]:[容器内部端口]Bind mounts : 将宿主机目录挂到到容器内部目录中。格式为[宿主机目录]:[容器内部目录]。这个springboot项目会将日志打印在容器 /home/developer/app/logs/ 目录下，将宿主机目录挂载到容器内部目录后，那么日志就会持久化容器外部的宿主机目录中。 (7) Maven打包(8) 运行 这里我们可以看到镜像名称为docker-demo:1.1，docker容器为docker-server 参考https://www.toutiao.com/i6702260511217549832/ 文章，有改动]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取外部配置文件]]></title>
    <url>%2F2019%2F10%2F05%2FSpringBoot%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候项目打包成一个jar 或者war ,通过java -jar 命令运行springboot 项目，因为springboot项目有自己的application.properties配置文件，但是我们打完包之后，它也会打到包里边，倒是也能打开压缩包修改properties 文件，但是也是较为麻烦。 现在有如下需求，比如客户需要在很多个服务器部署一套项目，但是它们的数据库连接不一样，我们不能针对于这么多服务器，多次打包，很恶心，当然可以打完包，复制一堆，分别修改压缩包里边的配置文件。 springboot 有读取外部配置文件的方法，如下优先级： 第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。 第二种是直接把配置文件放到jar包的同级目录。 第三种在classpath下建一个config文件夹，然后把配置文件放进去。 第四种是在classpath下直接放配置文件。 看到如上的优先级了吗？也就是说springboot默认是优先读取它本身同级目录下的一个config/application.properties文件的。我们通常在src/main/resources 文件夹下创建的application.properties文件的优先级竟然是最低的！！！。 展示 新建Project（本人使用的是IDEA），很简单，此处不再赘述。 在项目根目录下新建config文件夹 在config文件夹下新建application.properties或application.yml文件如图所示： 此处的优先级大于src目录下的application.yml文件. 我们可以把一些公共的配置文件代码放置到此处，这样就达到配置文件代码解耦合的目的了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(二)]]></title>
    <url>%2F2019%2F09%2F20%2FHexo%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在进行了Hexo和GitPage搭建博客之后需要将本地博客推送到GitPage上，具体操作下面在文章内介绍。 一、注册Github&emsp;&emsp;首先如果你还没有 Github 账号的先注册一个，此处不赘述 二、创建仓库点击 Start project 或者下面的 new repository 创建一个新的仓库 注：由于我已经有相同的仓库名了 所以此处会报错，请忽略此错误 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 三、配置SSH Key要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。如有需要请自行Google，此处不再赘述 四、部署到Github此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。 第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）1234deploy: type: git repo: github: git@github.com:@@@/@@@.github.io.git 注： @@@/@@@ 需要修改为自己的链接 第二：要安装一个部署插件 hexo-deployer-git。 npm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦 12hexo ghexo d 命令提示： hexo g 生成环境hexo d 部署环境hexo s 启动服务预览]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(一)]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[作为一个程序员，个人博客可以说是不可或缺的。它可以记录自己技术成长的过程，也可以供别人参考、给他人提供方便，还可以锻炼自己的表达能力等等。这几年陆陆续续的在很多地方写过博客（CSDN、个人服务器），但是都有一些缺陷，所以最后决定用GitPage作为自己博客的新起点 Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。 一、准备环境&emsp;&emsp;1.node.js&emsp;&emsp;2.git安装非常简单 此处不再赘述&emsp;&emsp;安装验证： 123git versionnode -vnpm -v 二、安装Hexo在命令行输入执行以下命令： npm install -g hexo-cli 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 新建完成后，指定文件夹的目录如下： 1234567├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。hexo s 以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
</search>
