<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String类常用方法源码分析]]></title>
    <url>%2F2019%2F10%2F24%2FString%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[环境: JDK8 String先看String类的定义 12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence 可以看到String类被final修饰,因此不能被继承.String类还实现了序列化接口Serializable,可比较的接口Comparable并指定泛型String,该接口必须实现int compareTo方法,最后还实现了字符序列CharSequence的接口,该接口常用的方法如chatAt(int index),length(),toString()等等. 构造字符串String类的无参构造函数 12345678/** * Initializes a newly created &#123;@code String&#125; object so that it represents * an empty character sequence. Note that use of this constructor is * unnecessary since Strings are immutable. */public String() &#123; this.value = &quot;&quot;.value;&#125; 其中value定义: 12/** The value is used for character storage. */ private final char value[]; 该构造函数创建了一个空的字符换并存在字符数组value中. 再看看一个有参的构造函数: 123456789101112/** * Allocates a new &#123;@code String&#125; so that it represents the sequence of * characters currently contained in the character array argument. The * contents of the character array are copied; subsequent modification of * the character array does not affect the newly created string. * * @param value * The initial value of the string */ public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; 该构造函数指定一个字符数组来创建一个字符序列,是通过Arrays的copyOf方法将字符数组拷贝到当前数组. 这样当修改字符数组的子串时,不会影响新字符数组. 下面经过一个简单的测试来验证下 12345678910111213141516public static void main(String[] args) &#123; char[] c1 = &#123;&apos;a&apos;, &apos;b&apos;&#125;; char[] c2 = c1; for (int i = 0; i &lt; c1.length; i++) &#123; if (i==1)&#123; c1[1]=&apos;c&apos;; &#125; &#125; for (char c : c1) &#123; System.out.println(&quot;c1:&quot;+c); &#125; for (char c : c2) &#123; System.out.println(&quot;c2:&quot;+c); &#125; &#125; 结果 1234c1:ac1:cc2:ac2:c 由上可知,在c1赋值给c2后,改变了c1中的值c2的值也会随之变化,这显然与我们想要的相悖,所以才会使用拷贝的方式,将c1与c2分开. 经过以上分析可以看出,下面两个语句是等价的,因为String类底层使用char[]数组来存储字符序列. 12char data[] = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;&#125;;String str = new String(data); string.value.length的代码等价于string.length123public int length() &#123; return value.length; &#125; 使用字节数组构造一个String在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。 String(byte[] bytes, Charset charset) 是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。 这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式。 如果我们在使用byte[]构造String的时候，使用的是下面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下： 12345678910111213141516171819static byte[] encode(String charsetName, char[] ca, int off, int len) throws UnsupportedEncodingException &#123; StringEncoder se = deref(encoder); String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName; if ((se == null) || !(csn.equals(se.requestedCharsetName()) || csn.equals(se.charsetName()))) &#123; se = null; try &#123; Charset cs = lookupCharset(csn); if (cs != null) se = new StringEncoder(cs, csn); &#125; catch (IllegalCharsetNameException x) &#123;&#125; if (se == null) throw new UnsupportedEncodingException (csn); set(encoder, se); &#125; return se.encode(ca, off, len);&#125; 上面是编码清单，下面是解码清单： 12345678910111213141516171819static char[] decode(String charsetName, byte[] ba, int off, int len) throws UnsupportedEncodingException &#123; StringDecoder sd = deref(decoder); String csn = (charsetName == null) ? &quot;ISO-8859-1&quot; : charsetName; if ((sd == null) || !(csn.equals(sd.requestedCharsetName()) || csn.equals(sd.charsetName()))) &#123; sd = null; try &#123; Charset cs = lookupCharset(csn); if (cs != null) sd = new StringDecoder(cs, csn); &#125; catch (IllegalCharsetNameException x) &#123;&#125; if (sd == null) throw new UnsupportedEncodingException(csn); set(decoder, sd); &#125; return sd.decode(ba, off, len);&#125; charAt再看charAt（int index）方法源码： 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; 该方法返回字符序列中下标为index的字符。并且index的范围：(0,value.length]. concat先看源码: 12345678910111213public String concat(String str) &#123; int otherLen = str.length(); //取得str字符串长度 if (otherLen == 0) &#123; //如果传入的字符串内容为空，则返回原字符串 return this; &#125; int len = value.length; //取得原字符串内容的长度 char buf[] = Arrays.copyOf(value, len + otherLen); //复制字符串的内容到char数组，并扩展长度 str.getChars(buf, len); //将str的内容复制到buf数组中，位置从len开始。在这一步完成两个字符串的拼接 return new String(buf, true); //将buf数组转化为新的String实例并返回 &#125;``` 步骤含义基本都在上面,这里着重描述一下getChars方法 void getChars(char dst[], int dstBegin) { System.arraycopy(value, 0, dst, dstBegin, value.length); } 123可以看出,链接字符换操作实际是字符串的拷贝.最后返回连接成功后的字符串.最后是一个特殊的私有包范围类型的构造方法，String除了提供了很多公有的供程序员使用的构造方法以外，还提供了一个包范围类型的构造方法（Jdk 8），我们看一下他是怎么样的： String(char[] value, boolean share) { // assert share : “unshared not supported”; this.value = value;} 12345678910111213141516171819从代码中我们可以看出，该方法和 String(char[] value)有两点区别：1. 第一个，该方法多了一个参数： boolean share，其实这个参数在方法体中根本没被使用，也给了注释，目前不支持使用false，只使用true。那么可以断定，加入这个share的只是为了区分于String(char[] value)方法，不加这个参数就没办法定义这个函数，只有参数不能才能进行重载。2. 第二个区别就是具体的方法实现不同。![在这里插入图片描述](https://img-blog.csdnimg.cn/20191024145625743.png)那么也就是说，这个方法构造出来的String和参数传过来的char[] value共享同一个数组。 那么，为什么Java会提供这样一个方法呢？ 首先，我们分析一下使用该构造函数的好处： 1. 首先，性能好，这个很简单，一个是直接给数组赋值（相当于直接将String的value的指针指向char[]数组），一个是逐一拷贝。当然是直接赋值快了。2. 其次，共享内部数组节约内存。3. 该方法之所以设置为包范围，是因为一旦该方法设置为公有，在外面可以访问的话，那就破坏了字符串的不可变性。## subStringsubstring有两个重载方法： public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } 12 public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } 1这两个重载方法都是先计算要截取的子串长度，判断边界最后返回调用new String(value, beginIndex, subLen)方法，我们来看一下这个方法： public String(char value[], int offset, int count) { if (offset &lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count &lt;= 0) { if (count &lt; 0) { throw new StringIndexOutOfBoundsException(count); } if (offset &lt;= value.length) { this.value = “”.value; return; } } // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset+count);} 123456offset指第一个匹配的字符序列的索引，count指子串的长度。最终该子串会被拷贝到字符数组value中，并且后续的字符数组的修改并不影响新创建的字符串。## contains先看一下源码: public boolean contains(CharSequence s) { return indexOf(s.toString()) &gt; -1;} 1可以看出,直接调用indexOf方法: public int indexOf(String str) { return indexOf(str, 0);} 12345``` public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125;``` 首先判断开始索引如果大于源字符串则返回，若目标字符串长度为0返回源字符串长度，否则返回-1.然后迭代查找字符，若全部源字符串都找到则返回第一个匹配的索引，否则返回-1.所以在public boolean contains(CharSequence s)方法中，若indexOf方法返回-1则返回false，否则返回true。## equals源码: public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n– != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 123该方法首先判断this == anObject ？，也就是说判断要比较的对象和当前对象是不是同一个对象，如果是直接返回true，如不是再继续比较，然后在判断anObject是不是String类型的，如果不是，直接返回false,如果是再继续比较，到了能终于比较字符数组的时候，他还是先比较了两个数组的长度，不一样直接返回false，一样再逐一比较值。## join public static String join(CharSequence delimiter, CharSequence… elements) { Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) { joiner.add(cs); } return joiner.toString();} 1231. **StringJoiner 类也是jdk1.8开始加入的通过分隔符或前缀或后缀来构造字符串的，底层是字符序列的拷贝。**2. requireNonNull方法校验参数不能为空,否则抛异常.源码: public static T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj;}``` ============================================== 参考文章: https://blog.csdn.net/u011726984/article/details/51326697]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[static关键字详解]]></title>
    <url>%2F2019%2F10%2F23%2Fstatic%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[static关键字的用途 static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途 — 摘自&lt;&lt;java编程思想&gt;&gt; 这段话用一句话来描述就是: 方便在没有创建对象的情况下来进行调用(方法/变量) 很显然，被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 static可以用来修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 static修饰方法 static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 此时可以看到,静态方法print2不能访问非静态变量与非静态方法.而非静态方法print1可以不需要new直接访问print2方法. 由此可以看出,print2方法时独立于对象存在的,可以直接通过类名调用.例如: Class.print2(); static修饰变量 static变量也成为静态变量,静态变量和非静态变量的区别是:静态变量被所有的对象所共享,在内存中只有一个副本,它当且仅当在类初次加载时会被初始化.而非静态变量所拥有的,在创建对象的时候被初始化,存在多个副本,各个对象拥有的副本互不影响. static成员变量的初始化顺序按照定义的顺序进行初始化. static修饰代码块static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能. static块可以置于类中的任何地方,类中可以有多个static块.在类初次加载时,会按照static块ed顺序来执行每个static块,并且只执行一次. 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。下面看个例子: 12345678910111213class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(&quot;1946&quot;); Date endDate = Date.valueOf(&quot;1964&quot;); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是用来这个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成这样效率会更好： 12345678910111213141516class Person&#123; private Date birthDate; private static Date startDate,endDate; static&#123; startDate = Date.valueOf(&quot;1946&quot;); endDate = Date.valueOf(&quot;1964&quot;); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 static关键字误区 static关键字会改变类中成员的访问权限吗？ ava中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。 能通过this访问静态成员变量吗？ 这里面主要考察队this和static的理解。this代表什么？this代表当前对象。而static变量是被对象所享有的，静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 static能作用于局部变量么？ static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。 常见的面试题 下面这段代码的输出结果是什么？12345678910111213141516171819202122232425public class Test extends Base&#123; static&#123; System.out.println(&quot;test static&quot;); &#125; public Test()&#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; class Base&#123; static&#123; System.out.println(&quot;base static&quot;); &#125; public Base()&#123; System.out.println(&quot;base constructor&quot;); &#125;&#125; 结果: 1234base statictest staticbase constructortest constructor 解析: 从main方法开始执行,先加载Test类 Test类继承Base类,因此先去加载Base类,发现有static代码块,便开始执行static代码块.此时输出: base static base类加载完成后,继续加载Test类,发现Test类中也有static方法,便开始执行static代码块,此时输出: test static 在加载完静态代码后,便继续执行main方法,在main方法中new Test()时会先调用父类的构造器,输出: base constructor 再调用自身的构造器,输出test constructor 这段代码的输出结果是什么？ 1234567891011121314151617181920212223242526272829303132333435public class Test &#123; Person person = new Person(&quot;Test&quot;); static&#123; System.out.println(&quot;test static&quot;); &#125; public Test() &#123; System.out.println(&quot;test constructor&quot;); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125; class Person&#123; static&#123; System.out.println(&quot;person static&quot;); &#125; public Person(String str) &#123; System.out.println(&quot;person &quot;+str); &#125;&#125; class MyClass extends Test &#123; Person person = new Person(&quot;MyClass&quot;); static&#123; System.out.println(&quot;myclass static&quot;); &#125; public MyClass() &#123; System.out.println(&quot;myclass constructor&quot;); &#125;&#125; 结果: 1234567test staticmyclass staticperson staticperson Testtest constructorperson MyClassmyclass constructor 先加载Test类,执行其中的static方法,输出:test static 再加载MyClass类中的static方法,输出:myclass static 在加载完static后,就通过构造器来生成对象.而在生成对象的时候,必须先初始化父类的成员变量,因此会执行Test中的Person person = new Person(),而Person类还没有被加载过,因此会先加载Person类中的static块,输出person static 继续执行Person的构造器,输出:person Test 继续执行Test类中的构造器,输出:test constructor.此时完成了父类的初始化 初始化自身,因此会继续执行MyClass中的Person person = new Person()，输出:person MyClass 执行myClass中的构造器,输出:myclass constructor 这段代码的输出结果是什么？12345678910111213public class Test &#123; static&#123; System.out.println(&quot;test static 1&quot;); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println(&quot;test static 2&quot;); &#125;&#125; 结果: 12test static 1test static 2 初始化时加载静态代码块,其余不解释]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java里的构造函数]]></title>
    <url>%2F2019%2F10%2F23%2Fjava%E9%87%8C%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Java里的构造函数(构造方法) 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们,即构造函数的重载。 构造函数的特点 ① 构造函数的主要作用是完成对象的初始化工作,如果写的类里面没有构造函数,那么编译器会默认加上一个无参数且方法体为空的构造函数,它能够把定义对象时的参数传给对象的域.意即当创建一个对象时,这个对象就被初始化,如果这是构造函数不为空,则在创建对象时就执行构造函数里面的代码. ② 构造函数的名称必须与类名相同,不包括大小写; ③ 构造函数没有返回值,也不能用void修饰,如果加上了返回值类型,那么这将使这个构造函数变成一个普通的方法,在运行时将产生找不到构造方法的错误. ④ 一个类可以定义多个构造犯法,如果在定义类时没有定义构造方法,则编译系统会自动插入一个无参数的默认构造函数,这个构造器不执行任何代码 ⑤ 构造方法可以重载,以参数的个数,类型,顺序区分.⑥ 在函数的继承里,子类必须调用父类的构造函数.但是,子类只能继承父类的默认构造函数,如果父类没有默认构造函数,那子类不能从父类继承默认构造函数,这时子类必须使用super来实现对父类的为默认构造函数的调用.在创建对象时,先调用父类默认构造函数对对象进行初始化,然后调用子类自身定义的构造函数. 针对1中的⑥进行代码展示 父类: 123456789public class Class &#123; int age; String name; Class(int age, String name) &#123; this.age = age; this.name = name; &#125;&#125; 父类中使用有参的构造方法,此时不会生成默认的无参构造方法. 子类: 我们先让子类继承父类,会产生如下报错 可以看到,java让Student类中实现父类的构造方法,代码完成后是这样的: 这就是刚才说的,子类必须使用super来实现对父类的非默认构造方法的调用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps搭建shadowsocks]]></title>
    <url>%2F2019%2F10%2F23%2Fvps%E6%90%AD%E5%BB%BAshadowsocks%2F</url>
    <content type="text"><![CDATA[出于程序员的本能，我尝试在外网上搭建了一个VPN（搭建成功后就删除了，证明自己搭建成功过就满足了），现在记录一下步骤 一、 购买服务器 经过筛选，我选择了vultr服务器，每月5美元，建议地址选Tokyo，操作系统选centos7，最好不要选8，配置选最小即可，然后部署服务器二、 部署shadowsocks 这里使用的是秋水逸冰的Python版一键安装脚本，使用方法如下： 1. 使用root用户，运行如下命令123wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 其中需要输入一些信息如IP、Port、password等，均可自己定义 安装完成后，脚本提示如下： 12345678 Congratulations, Shadowsocks-python server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/342.htmlEnjoy it! 单用户配置文件示例：配置文件路径：/etc/shadowsocks.json 12345678910&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_port&quot;:your_server_port, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;your_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 多用户多端口配置文件示例：配置文件路径：/etc/shadowsocks.json 123456789101112131415&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;your_encryption_method&quot;, &quot;fast_open&quot;: false&#125; 使用命令：启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 以上引用自 &gt; http://www.wangchao.info/1148.html 有改动 三、 KCPTun加速 搭建好了Shadowsocks相当于搭建成功了梯子，但是梯子太长，即时梯子带宽足够宽，线路质量也是不忍直视，此时就需要KCPTun了。 KCPTun是一个使用可信UDP来加速TCP传输速度的网络软件。 KCP 是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。 首先需要确认一下加速地址，大部分不能加速是因为加速地址配置错误 首先找到Shadowsocks端口，如8388，然后再命令行输入一下命令： 1netstat -nl | grep 8388 如果提示以上命令不存在，则输入 1ss -nl | grep 8388 然后你会看到类似下面的输出（着重看显示为红色的部分）： 情况一： 12tcp6 0 0 :::8388 :::* LISTEN udp6 0 0 :::8388 :::* 情况二： 12tcp 0 0 127.0.0.1:8388 :::* LISTEN udp 0 0 127.0.0.1:8388 :::* 情况三： 12tcp 0 0 0.0.0.0:8388 :::* LISTEN udp 0 0 0.0.0.0:8388 :::* 情况四： 12tcp 0 0 10.10.10.10:8388 :::* LISTEN udp 0 0 10.10.10.10:8388 :::* 情况五： 12udp UNCONN 0 0 *:1080 *:* tcp LISTEN 0 128 *:1080 *:* 若为情况1、情况2、情况5和情况3，那么你的加速地址可以为：加速 IP 127.0.0.1，加速端口 8388（你的 Shadowsocks 端口） 若为情况4，那么你的加速地址为：加速IP 10.10.10.10（你的服务器IP），加速端口8388（你的 Shadowsocks 端口） Kcptun 一键安装脚本 12wget --no-check-certificate -O kcptun.sh https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.shsh kcptun.sh 同样也需要一些自定义配置,其中的加速IP按上面说的填写。 注： 填写完成后会提示按任意键继续和CTRL+C退出，此时要按任意键 如果安装成功，应该能看到如下信息 12345678910111213141516171819202122232425262728293031323334353637&gt; 恭喜, Kcptun 服务端配置完毕！&gt; &gt; 正在获取当前安装的 Kcptun 版本...&gt; &gt; 服务器IP: 10.10.10.10&gt; 端口: 29900&gt; 加速地址: 127.0.0.1:8388&gt; 密码: 123456&gt; 加密方式 Crypt: salsa20&gt; &gt; 当前安装的 Kcptun 版本为: v20160922&gt; &gt; 推荐的客户端配置为: &gt; &#123;&gt; &quot;localaddr&quot;: &quot;:8388&quot;,&gt; &quot;remoteaddr&quot;: &quot;10.10.10.10:29900&quot;,&gt; &quot;key&quot;: &quot;123456&quot;,&gt; &quot;crypt&quot;: &quot;salsa20&quot;,&gt; &quot;mode&quot;: &quot;fast&quot;,&gt; &quot;mtu&quot;: 1350,&gt; &quot;sndwnd&quot;: 1024,&gt; &quot;rcvwnd&quot;: 1024,&gt; &quot;datashard&quot;: 10,&gt; &quot;parityshard&quot;: 3,&gt; &quot;dscp&quot;: 0,&gt; &quot;conn&quot;: 1,&gt; &quot;autoexpire&quot;: 60,&gt; &quot;nocomp&quot;: false&gt; &#125;&gt; &gt; 手机端参数可以使用：&gt; *******&gt; &gt; 其他参数请自行计算或设置, 详细信息可以查看: https://github.com/xtaci/kcptun&gt; &gt; Kcptun 安装目录: /usr/share/kcptun&gt; Kcptun 日志文件目录: /var/log/kcptun/ 请将以上的提示信息复制保存下来，后面配置客户端会用到这些提示信息。注意：服务端的 sndwnd 对应的是客户端的 recwnd，所以请不要问我为什么输出的客户端参数和你配置的服务端参数是反的。 安装之后，Kcptun 服务交由 Supervisor 管理。 Supervisor 相关命令： 1service supervisord &#123;start|stop|restart|status&#125; Kcptun 相关命令： 1supervisorctl &#123;start|stop|restart|status&#125; kcptun Supervisor 启动的时候会同时启动 Kcptun，运行 kcptun 相关命令时先确保 Supervisor 已启动。 四、客户端配置（windows，没有mac） 先下载一个Kcptun工具.按照kcptun执行完成以后保存的信息填入Kcptun中相关的位置 下载Shadowsocks，填写相关信息，注意：其中的密码和加密方式一定要与服务器shadowsocks配置的相同，否则不能联网。 到此位止，我的VPN就搭建好了，试一下可以访问谷歌而且很稳定。 在vultr上是按照时间付钱的，可以在不用的时候删掉服务器，不再扣钱。]]></content>
      <categories>
        <category>vps搭建shadowsocks</category>
      </categories>
      <tags>
        <tag>vps搭建shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建dubbo服务]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%90%AD%E5%BB%BAdubbo%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[dubbo目录结构如图所示：生产者为服务的被调用方生产者为服务的调用方API为生产者和消费者中间的桥梁，这个是必不可少的。原因： 如果没有API的话，消费者需要将生产者的包导入到本地仓库，这样就相当于把生产者的代码放到了本地，不符合微服务的理念 假如没有API的话，消费者需要将生产者的包导入到本地仓库，如果此时生产者的代码发生了变化，消费者必须每次手动清楚生产者的包进行重新导包，这样的设计是非常垃圾的。 假如有API的话，我们通过API远程调用生产者的接口，这样不管生产者的代码怎么变化，我们都是通过API调用的最新的代码。这种设计是才是合理的。一、POM。xml 根 pom.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;consumers&lt;/module&gt; &lt;module&gt;api&lt;/module&gt; &lt;module&gt;providers&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;revision&gt;2.7.1&lt;/revision&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; providers pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;providers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; consumers pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;consumers&lt;/artifactId&gt; &lt;properties&gt; &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;revision&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; api pom.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;api&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 二、 resources providers application.yml 1234567891011121314151617181920spring: application: name: providersdubbo: scan: base-packages: com.fengqi.providers.service protocol: name: dubbo port: 9010 registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8282demo: service: version: 1.0.0embedded: zookeeper: port: 2181 consumers application.yml 123456789101112131415161718spring: application: name: consumersdemo: service: version: 1.0.0embedded: zookeeper: port: 2181dubbo: registry: address: zookeeper://39.105.132.36:$&#123;embedded.zookeeper.port&#125; file: $&#123;user.home&#125;/dubbo-cache/$&#123;spring.application.name&#125;/dubbo.cacheserver: port: 8281 注： api不需要yml 三.、代码 providers 123456789101112131415161718 package com.fengqi.providers.service;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Service;import org.springframework.beans.factory.annotation.Value;@Service(version = "1.0.0")public class ApiServiceImpl implements ApiService &#123; @Value("$&#123;dubbo.application.name&#125;") private String serviceName; @Override public String sayHello(String name) &#123; return String.format("[%s] : Hello, %s", serviceName, name); &#125;&#125; consumers 1234567891011121314151617181920package com.fengqi.consumers.controller;import com.fengqi.api.ApiService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/test")public class ConsumersController &#123; @Reference(version = "1.0.0") private ApiService apiService; @GetMapping public String getProviders() &#123; return apiService.sayHello("李特"); &#125;&#125; api 12345package com.fengqi.api;public interface ApiService &#123; String sayHello(String name);&#125; 此时，一个多module的dubbo服务就已经完成了 ，运行看一下吧。 项目地址： https://github.com/litete/dubbo-zookeeper-demo.git]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea远程一键部署springboot到Docker]]></title>
    <url>%2F2019%2F10%2F06%2FIdea%E8%BF%9C%E7%A8%8B%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2springboot%E5%88%B0Docker%2F</url>
    <content type="text"><![CDATA[** Idea是Java开发利器，springboot是Java生态中最流行的微服务框架，docker是时下最火的容器技术，那么它们结合在一起会产生什么化学反应呢？** 一、 开发前准备 Docker的安装可以参考https://docs.docker.com/install/ 配置docker远程连接端口 1vi /usr/lib/systemd/system/docker.service 找到 ExecStart，在最后面添加 -H tcp://0.0.0.0:2375，如下图所示 重启docker 12systemctl daemon-reloadsystemctl restart docker 开放端口 1firewall-cmd --zone=public --add-port=2375/tcp --permanent Idea安装docker插件,重启 连接远程docker(1) 编辑配置(2) 填远程docker地址(3) 连接成功，会列出远程docker容器和镜像 二、新建项目 创建springboot项目 项目结构图(1) 配置pom文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;dockerDemo&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.fengqi&lt;/groupId&gt; &lt;artifactId&gt;web&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;name&gt;web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;configuration&gt; &lt;tasks&gt; &lt;copy todir="src/main/docker" file="target/$&#123;project.artifactId&#125;-$&#123;project.version&#125;.$&#123;project.packaging&#125;"&gt;&lt;/copy&gt; &lt;/tasks&gt; &lt;/configuration&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; (2) 在src/main目录下创建docker目录，并创建Dockerfile文件 123FROM openjdk:8-jdk-alpineADD *.jar app.jarENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"] (3) 在resource目录下创建application.properties文件 123logging.config=classpath:logback.xmllogging.path=/home/developer/app/logs/server.port=8990 (4) 创建DockerApplication文件 123456@SpringBootApplicationpublic class DockerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DockerApplication.class, args); &#125;&#125; (5) 创建DockerController文件 123456789@RestControllerpublic class DockerController &#123; static Log log = LogFactory.getLog(DockerController.class); @RequestMapping("/") public String index() &#123; log.info("Hello Docker!"); return "Hello Docker!"; &#125;&#125; (6) 增加配置命令解释Image tag : 指定镜像名称和tag，镜像名称为 docker-demo，tag为1.1Bind ports : 绑定宿主机端口到容器内部端口。格式为[宿主机端口]:[容器内部端口]Bind mounts : 将宿主机目录挂到到容器内部目录中。格式为[宿主机目录]:[容器内部目录]。这个springboot项目会将日志打印在容器 /home/developer/app/logs/ 目录下，将宿主机目录挂载到容器内部目录后，那么日志就会持久化容器外部的宿主机目录中。 (7) Maven打包(8) 运行 这里我们可以看到镜像名称为docker-demo:1.1，docker容器为docker-server 参考https://www.toutiao.com/i6702260511217549832/ 文章，有改动]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取外部配置文件]]></title>
    <url>%2F2019%2F10%2F05%2FSpringBoot%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候项目打包成一个jar 或者war ,通过java -jar 命令运行springboot 项目，因为springboot项目有自己的application.properties配置文件，但是我们打完包之后，它也会打到包里边，倒是也能打开压缩包修改properties 文件，但是也是较为麻烦。 现在有如下需求，比如客户需要在很多个服务器部署一套项目，但是它们的数据库连接不一样，我们不能针对于这么多服务器，多次打包，很恶心，当然可以打完包，复制一堆，分别修改压缩包里边的配置文件。 springboot 有读取外部配置文件的方法，如下优先级： 第一种是在jar包的同一目录下建一个config文件夹，然后把配置文件放到这个文件夹下。 第二种是直接把配置文件放到jar包的同级目录。 第三种在classpath下建一个config文件夹，然后把配置文件放进去。 第四种是在classpath下直接放配置文件。 看到如上的优先级了吗？也就是说springboot默认是优先读取它本身同级目录下的一个config/application.properties文件的。我们通常在src/main/resources 文件夹下创建的application.properties文件的优先级竟然是最低的！！！。 展示 新建Project（本人使用的是IDEA），很简单，此处不再赘述。 在项目根目录下新建config文件夹 在config文件夹下新建application.properties或application.yml文件如图所示： 此处的优先级大于src目录下的application.yml文件. 我们可以把一些公共的配置文件代码放置到此处，这样就达到配置文件代码解耦合的目的了]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(二)]]></title>
    <url>%2F2019%2F09%2F20%2FHexo%E4%BD%BF%E7%94%A8Next%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在进行了Hexo和GitPage搭建博客之后需要将本地博客推送到GitPage上，具体操作下面在文章内介绍。 一、注册Github&emsp;&emsp;首先如果你还没有 Github 账号的先注册一个，此处不赘述 二、创建仓库点击 Start project 或者下面的 new repository 创建一个新的仓库 注：由于我已经有相同的仓库名了 所以此处会报错，请忽略此错误 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 三、配置SSH Key要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。如有需要请自行Google，此处不再赘述 四、部署到Github此时，本地和Github的工作做得差不了，是时候把它们两个连接起来了。 第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）1234deploy: type: git repo: github: git@github.com:@@@/@@@.github.io.git 注： @@@/@@@ 需要修改为自己的链接 第二：要安装一个部署插件 hexo-deployer-git。 npm install hexo-deployer-git --save 最后执行以下命令就可以部署上传啦 12hexo ghexo d 命令提示： hexo g 生成环境hexo d 部署环境hexo s 启动服务预览]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo和Gitpage搭建博客(一)]]></title>
    <url>%2F2019%2F09%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGitpage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[作为一个程序员，个人博客可以说是不可或缺的。它可以记录自己技术成长的过程，也可以供别人参考、给他人提供方便，还可以锻炼自己的表达能力等等。这几年陆陆续续的在很多地方写过博客（CSDN、个人服务器），但是都有一些缺陷，所以最后决定用GitPage作为自己博客的新起点 Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。 一、准备环境&emsp;&emsp;1.node.js&emsp;&emsp;2.git安装非常简单 此处不再赘述&emsp;&emsp;安装验证： 123git versionnode -vnpm -v 二、安装Hexo在命令行输入执行以下命令： npm install -g hexo-cli 安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123hexo init myBlogcd myBlognpm install 注：myBlog为文件夹的名字 可根据自己的需求修改 新建完成后，指定文件夹的目录如下： 1234567├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── scaffolds # 模版文件夹├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹| ├── _drafts # 草稿文件| └── _posts # 文章Markdowm文件 └── themes # 主题文件夹 好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。hexo s 以下是我本地的预览效果，更换了 next 主题的，默认不是这个主题。]]></content>
      <categories>
        <category>Hexo+GitPage</category>
      </categories>
      <tags>
        <tag>Hexo+GitPage</tag>
      </tags>
  </entry>
</search>
